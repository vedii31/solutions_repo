{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Investigating the Range as a Function of the Angle of Projection 1. Introduction Projectile motion is a classical problem in physics, demonstrating fundamental principles of kinematics and dynamics. The study of projectile motion has extensive applications in fields like engineering, sports, ballistics, aerospace, and video game physics . This report explores how the range of a projectile depends on its angle of projection. By analyzing these dependencies, we uncover important insights into real-world problems, from optimizing a soccer kick to launching spacecrafts. Key Questions Explored: How does the range of a projectile change with launch angle? What is the optimal launch angle for maximum range? How do environmental factors (air resistance, wind, gravity variations) impact projectile motion? 2. Theoretical Foundations 2.1 Governing Equations of Motion Projectile motion follows Newton\u2019s Laws , particularly the equations of motion under uniform acceleration. Given an initial velocity \\(v_0\\) and launch angle \\(\\theta\\) , we break the motion into: Horizontal Motion \\[ x = v_0 \\cos(\\theta) t \\] \\[ v_x = v_0 \\cos(\\theta) \\quad (\\text{constant}) \\] Vertical Motion \\[ y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] \\[ v_y = v_0 \\sin(\\theta) - g t \\] where: - \\(g\\) is the acceleration due to gravity (9.81 m/s\u00b2 on Earth). 2.2 Time of Flight The projectile reaches the ground when \\(y = 0\\) : \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\] 2.3 Range Equation The horizontal distance (range) at landing is: \\[ R = v_0 \\cos(\\theta) t_f = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] From this equation, we note: Max range occurs at \\(\\theta = 45^\\circ\\) . Range is symmetric: \\(30^\\circ\\) and \\(60^\\circ\\) give the same range. 3. Advanced Theoretical Considerations 3.1 Finding the Maximum Range Taking the derivative of \\(R(\\theta)\\) and setting it to zero: \\[ \\frac{dR}{d\\theta} = \\frac{2 v_0^2 \\cos(2\\theta)}{g} = 0 \\] Solving for \\(\\theta\\) : \\[ 2\\theta = 90^\\circ \\Rightarrow \\theta = 45^\\circ \\] Thus, the maximum range is at \\(45^\\circ\\) . 3.2 Effect of Air Resistance With air resistance \\(F_d = \\frac{1}{2} C_d \\rho A v^2\\) , the equations become: \\[ m \\frac{dv_x}{dt} = -F_d \\cos(\\theta) \\] \\[ m \\frac{dv_y}{dt} = -mg - F_d \\sin(\\theta) \\] These equations require numerical methods for solutions. 4. Python Implementation 4.1 Range vs. Angle (Basic Model) import numpy as np import matplotlib.pyplot as plt def projectile_range(v0, theta, g=9.81): return (v0**2 * np.sin(2 * np.radians(theta))) / g angles = np.linspace(0, 90, 100) v0_values = [10, 20, 30] plt.figure(figsize=(8,5)) for v0 in v0_values: ranges = [projectile_range(v0, theta) for theta in angles] plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.axvline(45, linestyle='--', color='black', label='Max at 45\u00b0') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.title('Projectile Range vs. Launch Angle') plt.legend() plt.grid() plt.show() from mpl_toolkits.mplot3d import Axes3D fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') for theta in [30, 45, 60]: t = np.linspace(0, 2*v0*np.sin(np.radians(theta))/g, 100) x = v0 * np.cos(np.radians(theta)) * t y = v0 * np.sin(np.radians(theta)) * t - 0.5 * g * t**2 ax.plot(x, t, y, label=f'\u03b8 = {theta}\u00b0') ax.set_xlabel('Horizontal Distance') ax.set_ylabel('Time') ax.set_zlabel('Vertical Height') ax.legend() plt.show() def projectile_with_drag(v0, theta, g=9.81, Cd=0.47, rho=1.225, A=0.01, m=0.1, dt=0.01): vx = v0 * np.cos(np.radians(theta)) vy = v0 * np.sin(np.radians(theta)) x, y = 0, 0 positions = [] while y >= 0: v = np.sqrt(vx**2 + vy**2) Fd = 0.5 * Cd * rho * A * v**2 ax = -Fd * vx / m ay = -g - (Fd * vy / m) vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt positions.append((x, y)) return np.array(positions) pos = projectile_with_drag(20, 45) plt.plot(pos[:, 0], pos[:, 1], label='With Air Resistance') plt.xlabel('Horizontal Distance') plt.ylabel('Vertical Height') plt.title('Projectile Motion with Air Resistance') plt.legend() plt.grid() plt.show() 5. Real-World Applications Sports: Optimizing soccer free kicks, basketball shots, and javelin throws. Engineering: Calculating projectile paths in ballistics and aerospace. Space Science: Determining launch angles for interplanetary missions. Video Games: Simulating realistic projectile motion in physics engines. 6. Conclusion & Future Work Projectile motion is fundamental in physics, but real-world factors like air resistance, wind, and non-uniform gravity make it complex. Future studies can use: Machine Learning for predictive modeling of projectile behavior. CFD Simulations to analyze drag forces in different environments. Monte Carlo Methods for uncertainty analysis in real-world applications. This study provides a detailed framework for analyzing projectile motion and lays the foundation for more advanced research in physics, engineering, and beyond.","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-introduction","text":"Projectile motion is a classical problem in physics, demonstrating fundamental principles of kinematics and dynamics. The study of projectile motion has extensive applications in fields like engineering, sports, ballistics, aerospace, and video game physics . This report explores how the range of a projectile depends on its angle of projection. By analyzing these dependencies, we uncover important insights into real-world problems, from optimizing a soccer kick to launching spacecrafts.","title":"1. Introduction"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-questions-explored","text":"How does the range of a projectile change with launch angle? What is the optimal launch angle for maximum range? How do environmental factors (air resistance, wind, gravity variations) impact projectile motion?","title":"Key Questions Explored:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-theoretical-foundations","text":"","title":"2. Theoretical Foundations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#21-governing-equations-of-motion","text":"Projectile motion follows Newton\u2019s Laws , particularly the equations of motion under uniform acceleration. Given an initial velocity \\(v_0\\) and launch angle \\(\\theta\\) , we break the motion into:","title":"2.1 Governing Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion","text":"\\[ x = v_0 \\cos(\\theta) t \\] \\[ v_x = v_0 \\cos(\\theta) \\quad (\\text{constant}) \\]","title":"Horizontal Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion","text":"\\[ y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] \\[ v_y = v_0 \\sin(\\theta) - g t \\] where: - \\(g\\) is the acceleration due to gravity (9.81 m/s\u00b2 on Earth). 2.2 Time of Flight The projectile reaches the ground when \\(y = 0\\) : \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\] 2.3 Range Equation The horizontal distance (range) at landing is: \\[ R = v_0 \\cos(\\theta) t_f = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] From this equation, we note: Max range occurs at \\(\\theta = 45^\\circ\\) . Range is symmetric: \\(30^\\circ\\) and \\(60^\\circ\\) give the same range.","title":"Vertical Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-advanced-theoretical-considerations","text":"","title":"3. Advanced Theoretical Considerations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#31-finding-the-maximum-range","text":"Taking the derivative of \\(R(\\theta)\\) and setting it to zero: \\[ \\frac{dR}{d\\theta} = \\frac{2 v_0^2 \\cos(2\\theta)}{g} = 0 \\] Solving for \\(\\theta\\) : \\[ 2\\theta = 90^\\circ \\Rightarrow \\theta = 45^\\circ \\] Thus, the maximum range is at \\(45^\\circ\\) .","title":"3.1 Finding the Maximum Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#32-effect-of-air-resistance","text":"With air resistance \\(F_d = \\frac{1}{2} C_d \\rho A v^2\\) , the equations become: \\[ m \\frac{dv_x}{dt} = -F_d \\cos(\\theta) \\] \\[ m \\frac{dv_y}{dt} = -mg - F_d \\sin(\\theta) \\] These equations require numerical methods for solutions.","title":"3.2 Effect of Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-python-implementation","text":"","title":"4. Python Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#41-range-vs-angle-basic-model","text":"import numpy as np import matplotlib.pyplot as plt def projectile_range(v0, theta, g=9.81): return (v0**2 * np.sin(2 * np.radians(theta))) / g angles = np.linspace(0, 90, 100) v0_values = [10, 20, 30] plt.figure(figsize=(8,5)) for v0 in v0_values: ranges = [projectile_range(v0, theta) for theta in angles] plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.axvline(45, linestyle='--', color='black', label='Max at 45\u00b0') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.title('Projectile Range vs. Launch Angle') plt.legend() plt.grid() plt.show() from mpl_toolkits.mplot3d import Axes3D fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') for theta in [30, 45, 60]: t = np.linspace(0, 2*v0*np.sin(np.radians(theta))/g, 100) x = v0 * np.cos(np.radians(theta)) * t y = v0 * np.sin(np.radians(theta)) * t - 0.5 * g * t**2 ax.plot(x, t, y, label=f'\u03b8 = {theta}\u00b0') ax.set_xlabel('Horizontal Distance') ax.set_ylabel('Time') ax.set_zlabel('Vertical Height') ax.legend() plt.show() def projectile_with_drag(v0, theta, g=9.81, Cd=0.47, rho=1.225, A=0.01, m=0.1, dt=0.01): vx = v0 * np.cos(np.radians(theta)) vy = v0 * np.sin(np.radians(theta)) x, y = 0, 0 positions = [] while y >= 0: v = np.sqrt(vx**2 + vy**2) Fd = 0.5 * Cd * rho * A * v**2 ax = -Fd * vx / m ay = -g - (Fd * vy / m) vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt positions.append((x, y)) return np.array(positions) pos = projectile_with_drag(20, 45) plt.plot(pos[:, 0], pos[:, 1], label='With Air Resistance') plt.xlabel('Horizontal Distance') plt.ylabel('Vertical Height') plt.title('Projectile Motion with Air Resistance') plt.legend() plt.grid() plt.show()","title":"4.1 Range vs. Angle (Basic Model)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-real-world-applications","text":"","title":"5. Real-World Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#sports","text":"Optimizing soccer free kicks, basketball shots, and javelin throws.","title":"Sports:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#engineering","text":"Calculating projectile paths in ballistics and aerospace.","title":"Engineering:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#space-science","text":"Determining launch angles for interplanetary missions.","title":"Space Science:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#video-games","text":"Simulating realistic projectile motion in physics engines.","title":"Video Games:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#6-conclusion-future-work","text":"Projectile motion is fundamental in physics, but real-world factors like air resistance, wind, and non-uniform gravity make it complex. Future studies can use: Machine Learning for predictive modeling of projectile behavior. CFD Simulations to analyze drag forces in different environments. Monte Carlo Methods for uncertainty analysis in real-world applications. This study provides a detailed framework for analyzing projectile motion and lays the foundation for more advanced research in physics, engineering, and beyond.","title":"6. Conclusion &amp; Future Work"},{"location":"1%20Physics/1%20Mechanics/problemsecond/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum 1. Understanding the Physical System A pendulum is a fundamental mechanical system that exhibits a variety of motion types, including periodic, damped, and chaotic behaviors, depending on external influences. When damping (friction) and external periodic forcing are introduced, the motion becomes more complex and can exhibit chaotic behavior. The governing equation of motion for a forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement (radians). - \\(b\\) is the damping coefficient, accounting for resistive forces. - \\(g\\) is the acceleration due to gravity. - \\(L\\) is the length of the pendulum. - \\(A \\cos(\\omega t)\\) represents the external periodic driving force with amplitude \\(A\\) and frequency \\(\\omega\\) . Key Concepts Simple Harmonic Motion : If \\(b = 0\\) and \\(A = 0\\) , the motion is simple harmonic for small angles. Damped Motion : If \\(b > 0\\) and \\(A = 0\\) , oscillations decay over time due to resistive forces. Forced Motion : If \\(A > 0\\) , an external force drives the pendulum, leading to resonance and chaotic behavior. 2. Transforming the Equation for Numerical Methods The equation above is a second-order differential equation , which must be rewritten as a system of first-order equations for numerical solving. Defining State Variables We introduce: - \\(\\theta_1 = \\theta\\) (position) - \\(\\theta_2 = \\frac{d\\theta}{dt}\\) (velocity) Rewriting the system: \\[ \\frac{d\\theta_1}{dt} = \\theta_2 \\] \\[ \\frac{d\\theta_2}{dt} = -b\\theta_2 - \\frac{g}{L} \\sin\\theta_1 + A \\cos(\\omega t) \\] This form allows us to apply numerical integration techniques like Runge-Kutta (RK45) . 3. Choosing a Numerical Solver We employ the Runge-Kutta (RK45) method , which is well-suited for solving nonlinear differential equations. This method is preferred because: It handles nonlinearity effectively. It dynamically adjusts step size for accuracy. It is frequently used for chaotic systems like the forced damped pendulum. 4. Setting Up Initial Conditions The initial state of the pendulum significantly affects its behavior. We define: \\[ \\theta(0) = \\theta_0, \\quad \\frac{d\\theta}{dt}(0) = \\omega_0 \\] For example: - Small initial displacement : \\(\\theta_0 = 0.1\\) rad. - Initially at rest : \\(\\omega_0 = 0\\) rad/s. 5. Running the Simulation To numerically integrate the system: 1. Define the time span for simulation (e.g., \\(t \\in [0, 50]\\) ). 2. Solve the equations using the RK45 method . 3. Store and analyze the results over time. Implementation in Python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # Gravity (m/s^2) L = 1.0 # Length of the pendulum (m) b = 0.2 # Damping coefficient omega = 2.0 # Driving frequency # Define the system of ODEs def forced_damped_pendulum(t, y, A, omega): theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Initial conditions t0, t_end = 0, 50 initial_conditions = [0.1, 0] # Small initial angle and zero initial velocity # Solve the system time_eval = np.linspace(t0, t_end, 2000) A = 1.2 # Set A for initial run sol = solve_ivp(forced_damped_pendulum, [t0, t_end], initial_conditions, args=(A, omega), t_eval=time_eval, method='RK45') # Extract results theta = sol.y[0] omega_values = sol.y[1] time = sol.t # Time Series Plot plt.figure(figsize=(10, 5)) plt.plot(time, theta, label=r'$\\theta(t)$', color='b') plt.xlabel('Time (s)') plt.ylabel('Angular Position (rad)') plt.title('Forced Damped Pendulum Motion') plt.legend() plt.grid() plt.show() # Phase Portrait plt.figure(figsize=(6, 6)) plt.plot(theta, omega_values, lw=0.8, color='r') plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title('Phase Portrait') plt.grid() plt.show() # Poincar\u00e9 Section (Stroboscopic Map) omega_scalar = float(np.mean(omega_values)) if isinstance(omega_values, np.ndarray) else omega if omega_scalar != 0: poincare_times = np.arange(t0, t_end, 2 * np.pi / omega_scalar) else: poincare_times = np.linspace(t0, t_end, 50) # Fallback to evenly spaced points theta_poincare = np.interp(poincare_times, time, theta) omega_poincare = np.interp(poincare_times, time, omega_values) plt.figure(figsize=(6, 6)) plt.scatter(theta_poincare, omega_poincare, s=10, color='green') plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title('Poincar\u00e9 Section') plt.grid() plt.show() # Bifurcation Diagram - Sweeping Driving Force Amplitude A_values = np.linspace(0, 2, 50) final_theta = [] for A_val in A_values: sol = solve_ivp(forced_damped_pendulum, [t0, t_end], initial_conditions, args=(A_val, omega), t_eval=np.linspace(t_end-10, t_end, 500), method='RK45') final_theta.append(sol.y[0][-1]) plt.figure(figsize=(10, 6)) plt.scatter(A_values, final_theta, s=1, color='blue') plt.xlabel('Driving Force Amplitude (A)') plt.ylabel('Final Angular Position (rad)') plt.title('Bifurcation Diagram') plt.grid() plt.show() 6. Visualizing Results After solving for \\(\\theta(t)\\) , we analyze its behavior using different graphical representations: (a) Time Series Plot Shows how \\(\\theta(t)\\) evolves over time. Helps detect periodicity, resonance, or chaotic motion. (b) Phase Portrait Plots angular position ( \\(\\theta\\) ) vs. angular velocity ( \\(\\dot{\\theta}\\) ) . Closed loops indicate periodic motion, while scattered points suggest chaos. (c) Poincar\u00e9 Section Captures stroboscopic points sampled at regular intervals. Helps distinguish between regular and chaotic motion . (d) Bifurcation Diagram Varies the driving force amplitude (A) to observe transitions in motion. Reveals transitions from stability to chaos . 7. Analyzing the Behavior Different values of parameters lead to different types of motion: (a) Small Forcing and Weak Damping The pendulum exhibits simple periodic oscillations . The phase portrait shows smooth elliptical loops . (b) Resonance Condition When \\(\\omega\\) matches the natural frequency \\(\\omega_0 = \\sqrt{g/L}\\) , large oscillations occur. Energy accumulates over time, leading to strong oscillations. (c) Strong Damping Oscillations decay quickly, leading to overdamped motion . (d) Chaotic Motion For specific values of \\(A\\) and \\(\\omega\\) , the system exhibits sensitive dependence on initial conditions . Small changes in \\(\\theta_0\\) lead to divergent trajectories (butterfly effect). 8. Conclusion The forced damped pendulum is a rich nonlinear system that displays a variety of behaviors, from periodic to chaotic motion. Using numerical simulations , we can analyze its response to different parameters. Tools like Poincar\u00e9 sections and bifurcation diagrams help classify its dynamical regimes.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#1-understanding-the-physical-system","text":"A pendulum is a fundamental mechanical system that exhibits a variety of motion types, including periodic, damped, and chaotic behaviors, depending on external influences. When damping (friction) and external periodic forcing are introduced, the motion becomes more complex and can exhibit chaotic behavior. The governing equation of motion for a forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement (radians). - \\(b\\) is the damping coefficient, accounting for resistive forces. - \\(g\\) is the acceleration due to gravity. - \\(L\\) is the length of the pendulum. - \\(A \\cos(\\omega t)\\) represents the external periodic driving force with amplitude \\(A\\) and frequency \\(\\omega\\) .","title":"1. Understanding the Physical System"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#key-concepts","text":"Simple Harmonic Motion : If \\(b = 0\\) and \\(A = 0\\) , the motion is simple harmonic for small angles. Damped Motion : If \\(b > 0\\) and \\(A = 0\\) , oscillations decay over time due to resistive forces. Forced Motion : If \\(A > 0\\) , an external force drives the pendulum, leading to resonance and chaotic behavior.","title":"Key Concepts"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#2-transforming-the-equation-for-numerical-methods","text":"The equation above is a second-order differential equation , which must be rewritten as a system of first-order equations for numerical solving.","title":"2. Transforming the Equation for Numerical Methods"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#defining-state-variables","text":"We introduce: - \\(\\theta_1 = \\theta\\) (position) - \\(\\theta_2 = \\frac{d\\theta}{dt}\\) (velocity) Rewriting the system: \\[ \\frac{d\\theta_1}{dt} = \\theta_2 \\] \\[ \\frac{d\\theta_2}{dt} = -b\\theta_2 - \\frac{g}{L} \\sin\\theta_1 + A \\cos(\\omega t) \\] This form allows us to apply numerical integration techniques like Runge-Kutta (RK45) .","title":"Defining State Variables"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#3-choosing-a-numerical-solver","text":"We employ the Runge-Kutta (RK45) method , which is well-suited for solving nonlinear differential equations. This method is preferred because: It handles nonlinearity effectively. It dynamically adjusts step size for accuracy. It is frequently used for chaotic systems like the forced damped pendulum.","title":"3. Choosing a Numerical Solver"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#4-setting-up-initial-conditions","text":"The initial state of the pendulum significantly affects its behavior. We define: \\[ \\theta(0) = \\theta_0, \\quad \\frac{d\\theta}{dt}(0) = \\omega_0 \\] For example: - Small initial displacement : \\(\\theta_0 = 0.1\\) rad. - Initially at rest : \\(\\omega_0 = 0\\) rad/s.","title":"4. Setting Up Initial Conditions"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#5-running-the-simulation","text":"To numerically integrate the system: 1. Define the time span for simulation (e.g., \\(t \\in [0, 50]\\) ). 2. Solve the equations using the RK45 method . 3. Store and analyze the results over time.","title":"5. Running the Simulation"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#implementation-in-python","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # Gravity (m/s^2) L = 1.0 # Length of the pendulum (m) b = 0.2 # Damping coefficient omega = 2.0 # Driving frequency # Define the system of ODEs def forced_damped_pendulum(t, y, A, omega): theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Initial conditions t0, t_end = 0, 50 initial_conditions = [0.1, 0] # Small initial angle and zero initial velocity # Solve the system time_eval = np.linspace(t0, t_end, 2000) A = 1.2 # Set A for initial run sol = solve_ivp(forced_damped_pendulum, [t0, t_end], initial_conditions, args=(A, omega), t_eval=time_eval, method='RK45') # Extract results theta = sol.y[0] omega_values = sol.y[1] time = sol.t # Time Series Plot plt.figure(figsize=(10, 5)) plt.plot(time, theta, label=r'$\\theta(t)$', color='b') plt.xlabel('Time (s)') plt.ylabel('Angular Position (rad)') plt.title('Forced Damped Pendulum Motion') plt.legend() plt.grid() plt.show() # Phase Portrait plt.figure(figsize=(6, 6)) plt.plot(theta, omega_values, lw=0.8, color='r') plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title('Phase Portrait') plt.grid() plt.show() # Poincar\u00e9 Section (Stroboscopic Map) omega_scalar = float(np.mean(omega_values)) if isinstance(omega_values, np.ndarray) else omega if omega_scalar != 0: poincare_times = np.arange(t0, t_end, 2 * np.pi / omega_scalar) else: poincare_times = np.linspace(t0, t_end, 50) # Fallback to evenly spaced points theta_poincare = np.interp(poincare_times, time, theta) omega_poincare = np.interp(poincare_times, time, omega_values) plt.figure(figsize=(6, 6)) plt.scatter(theta_poincare, omega_poincare, s=10, color='green') plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title('Poincar\u00e9 Section') plt.grid() plt.show() # Bifurcation Diagram - Sweeping Driving Force Amplitude A_values = np.linspace(0, 2, 50) final_theta = [] for A_val in A_values: sol = solve_ivp(forced_damped_pendulum, [t0, t_end], initial_conditions, args=(A_val, omega), t_eval=np.linspace(t_end-10, t_end, 500), method='RK45') final_theta.append(sol.y[0][-1]) plt.figure(figsize=(10, 6)) plt.scatter(A_values, final_theta, s=1, color='blue') plt.xlabel('Driving Force Amplitude (A)') plt.ylabel('Final Angular Position (rad)') plt.title('Bifurcation Diagram') plt.grid() plt.show()","title":"Implementation in Python"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#6-visualizing-results","text":"After solving for \\(\\theta(t)\\) , we analyze its behavior using different graphical representations:","title":"6. Visualizing Results"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#a-time-series-plot","text":"Shows how \\(\\theta(t)\\) evolves over time. Helps detect periodicity, resonance, or chaotic motion.","title":"(a) Time Series Plot"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#b-phase-portrait","text":"Plots angular position ( \\(\\theta\\) ) vs. angular velocity ( \\(\\dot{\\theta}\\) ) . Closed loops indicate periodic motion, while scattered points suggest chaos.","title":"(b) Phase Portrait"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#c-poincare-section","text":"Captures stroboscopic points sampled at regular intervals. Helps distinguish between regular and chaotic motion .","title":"(c) Poincar\u00e9 Section"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#d-bifurcation-diagram","text":"Varies the driving force amplitude (A) to observe transitions in motion. Reveals transitions from stability to chaos .","title":"(d) Bifurcation Diagram"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#7-analyzing-the-behavior","text":"Different values of parameters lead to different types of motion:","title":"7. Analyzing the Behavior"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#a-small-forcing-and-weak-damping","text":"The pendulum exhibits simple periodic oscillations . The phase portrait shows smooth elliptical loops .","title":"(a) Small Forcing and Weak Damping"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#b-resonance-condition","text":"When \\(\\omega\\) matches the natural frequency \\(\\omega_0 = \\sqrt{g/L}\\) , large oscillations occur. Energy accumulates over time, leading to strong oscillations.","title":"(b) Resonance Condition"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#c-strong-damping","text":"Oscillations decay quickly, leading to overdamped motion .","title":"(c) Strong Damping"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#d-chaotic-motion","text":"For specific values of \\(A\\) and \\(\\omega\\) , the system exhibits sensitive dependence on initial conditions . Small changes in \\(\\theta_0\\) lead to divergent trajectories (butterfly effect).","title":"(d) Chaotic Motion"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#8-conclusion","text":"The forced damped pendulum is a rich nonlinear system that displays a variety of behaviors, from periodic to chaotic motion. Using numerical simulations , we can analyze its response to different parameters. Tools like Poincar\u00e9 sections and bifurcation diagrams help classify its dynamical regimes.","title":"8. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 # Orbital Period and Orbital Radius Motivation Kepler's Third Law provides a fundamental insight into orbital mechanics: The square of the orbital period ( \\(T^2\\) ) of a planet is directly proportional to the cube of the semi-major axis ( \\(r^3\\) ) of its orbit: \\[ T^2 \\propto r^3 \\] This law is essential for understanding the motion of celestial bodies under the influence of gravity. Derivation for Circular Orbits Consider a body of mass \\(m\\) orbiting a larger mass \\(M\\) (e.g., a planet orbiting the Sun) in a circular orbit. Gravitational force provides the necessary centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Simplify and solve for velocity \\(v\\) : \\[ v^2 = \\frac{G M}{r} \\] Orbital period is: \\[ T = \\frac{2\\pi r}{v} \\] Substitute \\(v\\) : \\[ T = 2\\pi r \\sqrt{\\frac{r}{G M}} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] Therefore, \\[ T^2 = \\frac{4\\pi^2 r^3}{G M} \\] This confirms Kepler's Third Law: \\[ T^2 \\propto r^3 \\] Implications in Astronomy Allows determination of planetary masses. Enables calculation of distances in planetary systems. Satellite orbit planning relies heavily on this law. Used in exoplanet studies to estimate star and planet properties. Real-World Examples Example: Moon Around Earth Orbital radius \\(r \\approx 3.84 \\times 10^8\\) m Orbital period \\(T \\approx 27.3\\) days \\(= 2.36 \\times 10^6\\) s Compute \\(\\frac{T^2}{r^3}\\) : \\[ \\frac{(2.36 \\times 10^6)^2}{(3.84 \\times 10^8)^3} \\approx 2.95 \\times 10^{-14} \\] Example: Earth Around Sun \\(r \\approx 1.5 \\times 10^{11}\\) m \\(T = 1\\) year \\(= 3.15 \\times 10^7\\) s \\[ \\frac{T^2}{r^3} \\approx 2.96 \\times 10^{-19} \\] Python Simulation of Circular Orbits import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # mass of Earth (kg) radii = np.linspace(7e6, 4.2e7, 100) # from 7000 km to 42000 km # Calculate orbital period T for each radius T = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Plot T^2 vs r^3 plt.figure() plt.plot(radii**3, T**2, label=r'$T^2 \\propto r^3$') plt.xlabel(r'Orbital Radius Cubed $r^3$ (m$^3$)') plt.ylabel(r'Orbital Period Squared $T^2$ (s$^2$)') plt.title(\"Kepler's Third Law: $T^2$ vs $r^3$\") plt.grid(True) plt.legend() plt.show() Extension to Elliptical Orbits Kepler's Third Law also holds for elliptical orbits when \\(r\\) is replaced with the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4\\pi^2 a^3}{G M} \\] This general form explains motions of planets, comets, and exoplanets with non-circular orbits.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"# Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"Kepler's Third Law provides a fundamental insight into orbital mechanics: The square of the orbital period ( \\(T^2\\) ) of a planet is directly proportional to the cube of the semi-major axis ( \\(r^3\\) ) of its orbit: \\[ T^2 \\propto r^3 \\] This law is essential for understanding the motion of celestial bodies under the influence of gravity.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-for-circular-orbits","text":"Consider a body of mass \\(m\\) orbiting a larger mass \\(M\\) (e.g., a planet orbiting the Sun) in a circular orbit. Gravitational force provides the necessary centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Simplify and solve for velocity \\(v\\) : \\[ v^2 = \\frac{G M}{r} \\] Orbital period is: \\[ T = \\frac{2\\pi r}{v} \\] Substitute \\(v\\) : \\[ T = 2\\pi r \\sqrt{\\frac{r}{G M}} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] Therefore, \\[ T^2 = \\frac{4\\pi^2 r^3}{G M} \\] This confirms Kepler's Third Law: \\[ T^2 \\propto r^3 \\]","title":"Derivation for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications-in-astronomy","text":"Allows determination of planetary masses. Enables calculation of distances in planetary systems. Satellite orbit planning relies heavily on this law. Used in exoplanet studies to estimate star and planet properties.","title":"Implications in Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"","title":"Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-moon-around-earth","text":"Orbital radius \\(r \\approx 3.84 \\times 10^8\\) m Orbital period \\(T \\approx 27.3\\) days \\(= 2.36 \\times 10^6\\) s Compute \\(\\frac{T^2}{r^3}\\) : \\[ \\frac{(2.36 \\times 10^6)^2}{(3.84 \\times 10^8)^3} \\approx 2.95 \\times 10^{-14} \\]","title":"Example: Moon Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-earth-around-sun","text":"\\(r \\approx 1.5 \\times 10^{11}\\) m \\(T = 1\\) year \\(= 3.15 \\times 10^7\\) s \\[ \\frac{T^2}{r^3} \\approx 2.96 \\times 10^{-19} \\]","title":"Example: Earth Around Sun"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-simulation-of-circular-orbits","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # mass of Earth (kg) radii = np.linspace(7e6, 4.2e7, 100) # from 7000 km to 42000 km # Calculate orbital period T for each radius T = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Plot T^2 vs r^3 plt.figure() plt.plot(radii**3, T**2, label=r'$T^2 \\propto r^3$') plt.xlabel(r'Orbital Radius Cubed $r^3$ (m$^3$)') plt.ylabel(r'Orbital Period Squared $T^2$ (s$^2$)') plt.title(\"Kepler's Third Law: $T^2$ vs $r^3$\") plt.grid(True) plt.legend() plt.show()","title":"Python Simulation of Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extension-to-elliptical-orbits","text":"Kepler's Third Law also holds for elliptical orbits when \\(r\\) is replaced with the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4\\pi^2 a^3}{G M} \\] This general form explains motions of planets, comets, and exoplanets with non-circular orbits.","title":"Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 # Escape Velocities and Cosmic Velocities Motivation Escape velocity and the concept of cosmic velocities are essential to the understanding of gravitational dynamics in astrodynamics and interplanetary travel. They define the energy thresholds needed to transition between different gravitational regimes. This knowledge is crucial in designing space missions\u2014from launching satellites to exploring other planets and venturing beyond the solar system. Definitions First Cosmic Velocity ( \\(v_1\\) ) Also known as orbital velocity, this is the minimum velocity an object must maintain to stay in a stable circular orbit just above the surface of a celestial body: \\[ v_1 = \\sqrt{\\frac{G M}{R}} \\] Where: - \\(G\\) is the gravitational constant - \\(M\\) is the mass of the celestial body - \\(R\\) is the radius of the celestial body Second Cosmic Velocity ( \\(v_2\\) ) Escape velocity is the minimum speed needed to break free from a celestial body's gravitational pull without further propulsion: \\[ v_2 = \\sqrt{\\frac{2 G M}{R}} = \\sqrt{2} v_1 \\] This speed allows an object to move to infinity with zero residual velocity, assuming no resistance. Third Cosmic Velocity ( \\(v_3\\) ) This is the minimum velocity required for a spacecraft to escape not only Earth\u2019s gravity but also the Sun\u2019s, effectively allowing it to exit the solar system: \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{orbital}}^2} \\] Where \\(v_{\\text{orbital}}\\) is the orbital speed of the planet around the Sun. Factors Affecting Cosmic Velocities Mass ( \\(M\\) ) : Higher planetary mass increases the gravitational attraction, raising all three velocities. Radius ( \\(R\\) ) : Smaller radius increases surface gravity, raising the required velocities. Distance from other bodies : For \\(v_3\\) , the position in the solar system matters due to gravitational influence from the Sun and other planets. Python Code: Cosmic Velocities Simulation import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant in m^3/kg/s^2 # Planetary data: name, mass (kg), radius (m), orbital speed around Sun (m/s) bodies = { 'Earth': {'mass': 5.972e24, 'radius': 6.371e6, 'v_orbit': 29780}, 'Mars': {'mass': 6.417e23, 'radius': 3.390e6, 'v_orbit': 24070}, 'Jupiter': {'mass': 1.898e27, 'radius': 6.9911e7, 'v_orbit': 13070}, 'Moon': {'mass': 7.347e22, 'radius': 1.737e6, 'v_orbit': 1022}, 'Mercury': {'mass': 3.301e23, 'radius': 2.439e6, 'v_orbit': 47400}, 'Venus': {'mass': 4.867e24, 'radius': 6.052e6, 'v_orbit': 35000}, } # Calculate velocities results = {} for body, data in bodies.items(): M, R, v_orbit = data['mass'], data['radius'], data['v_orbit'] v1 = np.sqrt(G * M / R) v2 = np.sqrt(2 * G * M / R) v3 = np.sqrt(v2**2 + v_orbit**2) results[body] = {'v1': v1, 'v2': v2, 'v3': v3} # Print results print(\"Cosmic Velocities (in km/s):\\n\") for body, velocities in results.items(): print(f\"{body}:\") print(f\" First Cosmic Velocity (v1): {velocities['v1'] / 1000:.2f} km/s\") print(f\" Second Cosmic Velocity (v2): {velocities['v2'] / 1000:.2f} km/s\") print(f\" Third Cosmic Velocity (v3): {velocities['v3'] / 1000:.2f} km/s\\n\") # Visualization labels = list(bodies.keys()) v1_vals = [results[body]['v1'] / 1000 for body in labels] v2_vals = [results[body]['v2'] / 1000 for body in labels] v3_vals = [results[body]['v3'] / 1000 for body in labels] x = np.arange(len(labels)) width = 0.25 plt.figure(figsize=(12,7)) plt.bar(x - width, v1_vals, width, label='v1 - Orbital') plt.bar(x, v2_vals, width, label='v2 - Escape') plt.bar(x + width, v3_vals, width, label='v3 - Interstellar') plt.xticks(x, labels) plt.ylabel('Velocity (km/s)') plt.title('First, Second, and Third Cosmic Velocities') plt.legend() plt.grid(True) plt.tight_layout() plt.show() Analysis and Real-World Context Earth \\(v_1 \\approx 7.91\\) km/s: used for satellites in low Earth orbit. \\(v_2 \\approx 11.19\\) km/s: needed for lunar and interplanetary missions. \\(v_3 \\approx 42.1\\) km/s: required for spacecraft to leave the Solar System. Mars Lower gravity results in lower escape and orbital velocities. Useful for future Mars colonization and exploration missions. Jupiter Enormous gravity increases required velocities significantly. Missions to Jupiter require major energy inputs or gravity assists. Other Bodies The Moon's low gravity makes it an ideal candidate for a space station. Venus and Mercury, while closer to the Sun, still require precision due to solar gravity. Importance in Space Exploration First Cosmic Velocity : Key for satellite deployment and orbital stations. Second Cosmic Velocity : Used in deep-space missions (e.g., Mars, asteroids). Third Cosmic Velocity : Enables interstellar exploration (e.g., Voyager 1 & 2). Understanding and optimizing for these velocities ensures cost-effective and technically feasible space missions. Every planetary mission, satellite launch, or interstellar probe relies on these fundamental velocity thresholds.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"# Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"Escape velocity and the concept of cosmic velocities are essential to the understanding of gravitational dynamics in astrodynamics and interplanetary travel. They define the energy thresholds needed to transition between different gravitational regimes. This knowledge is crucial in designing space missions\u2014from launching satellites to exploring other planets and venturing beyond the solar system.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions","text":"","title":"Definitions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-v_1","text":"Also known as orbital velocity, this is the minimum velocity an object must maintain to stay in a stable circular orbit just above the surface of a celestial body: \\[ v_1 = \\sqrt{\\frac{G M}{R}} \\] Where: - \\(G\\) is the gravitational constant - \\(M\\) is the mass of the celestial body - \\(R\\) is the radius of the celestial body","title":"First Cosmic Velocity (\\(v_1\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-v_2","text":"Escape velocity is the minimum speed needed to break free from a celestial body's gravitational pull without further propulsion: \\[ v_2 = \\sqrt{\\frac{2 G M}{R}} = \\sqrt{2} v_1 \\] This speed allows an object to move to infinity with zero residual velocity, assuming no resistance.","title":"Second Cosmic Velocity (\\(v_2\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-v_3","text":"This is the minimum velocity required for a spacecraft to escape not only Earth\u2019s gravity but also the Sun\u2019s, effectively allowing it to exit the solar system: \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{orbital}}^2} \\] Where \\(v_{\\text{orbital}}\\) is the orbital speed of the planet around the Sun.","title":"Third Cosmic Velocity (\\(v_3\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#factors-affecting-cosmic-velocities","text":"Mass ( \\(M\\) ) : Higher planetary mass increases the gravitational attraction, raising all three velocities. Radius ( \\(R\\) ) : Smaller radius increases surface gravity, raising the required velocities. Distance from other bodies : For \\(v_3\\) , the position in the solar system matters due to gravitational influence from the Sun and other planets.","title":"Factors Affecting Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-code-cosmic-velocities-simulation","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant in m^3/kg/s^2 # Planetary data: name, mass (kg), radius (m), orbital speed around Sun (m/s) bodies = { 'Earth': {'mass': 5.972e24, 'radius': 6.371e6, 'v_orbit': 29780}, 'Mars': {'mass': 6.417e23, 'radius': 3.390e6, 'v_orbit': 24070}, 'Jupiter': {'mass': 1.898e27, 'radius': 6.9911e7, 'v_orbit': 13070}, 'Moon': {'mass': 7.347e22, 'radius': 1.737e6, 'v_orbit': 1022}, 'Mercury': {'mass': 3.301e23, 'radius': 2.439e6, 'v_orbit': 47400}, 'Venus': {'mass': 4.867e24, 'radius': 6.052e6, 'v_orbit': 35000}, } # Calculate velocities results = {} for body, data in bodies.items(): M, R, v_orbit = data['mass'], data['radius'], data['v_orbit'] v1 = np.sqrt(G * M / R) v2 = np.sqrt(2 * G * M / R) v3 = np.sqrt(v2**2 + v_orbit**2) results[body] = {'v1': v1, 'v2': v2, 'v3': v3} # Print results print(\"Cosmic Velocities (in km/s):\\n\") for body, velocities in results.items(): print(f\"{body}:\") print(f\" First Cosmic Velocity (v1): {velocities['v1'] / 1000:.2f} km/s\") print(f\" Second Cosmic Velocity (v2): {velocities['v2'] / 1000:.2f} km/s\") print(f\" Third Cosmic Velocity (v3): {velocities['v3'] / 1000:.2f} km/s\\n\") # Visualization labels = list(bodies.keys()) v1_vals = [results[body]['v1'] / 1000 for body in labels] v2_vals = [results[body]['v2'] / 1000 for body in labels] v3_vals = [results[body]['v3'] / 1000 for body in labels] x = np.arange(len(labels)) width = 0.25 plt.figure(figsize=(12,7)) plt.bar(x - width, v1_vals, width, label='v1 - Orbital') plt.bar(x, v2_vals, width, label='v2 - Escape') plt.bar(x + width, v3_vals, width, label='v3 - Interstellar') plt.xticks(x, labels) plt.ylabel('Velocity (km/s)') plt.title('First, Second, and Third Cosmic Velocities') plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"Python Code: Cosmic Velocities Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#analysis-and-real-world-context","text":"","title":"Analysis and Real-World Context"},{"location":"1%20Physics/2%20Gravity/Problem_2/#earth","text":"\\(v_1 \\approx 7.91\\) km/s: used for satellites in low Earth orbit. \\(v_2 \\approx 11.19\\) km/s: needed for lunar and interplanetary missions. \\(v_3 \\approx 42.1\\) km/s: required for spacecraft to leave the Solar System.","title":"Earth"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mars","text":"Lower gravity results in lower escape and orbital velocities. Useful for future Mars colonization and exploration missions.","title":"Mars"},{"location":"1%20Physics/2%20Gravity/Problem_2/#jupiter","text":"Enormous gravity increases required velocities significantly. Missions to Jupiter require major energy inputs or gravity assists.","title":"Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#other-bodies","text":"The Moon's low gravity makes it an ideal candidate for a space station. Venus and Mercury, while closer to the Sun, still require precision due to solar gravity.","title":"Other Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_2/#importance-in-space-exploration","text":"First Cosmic Velocity : Key for satellite deployment and orbital stations. Second Cosmic Velocity : Used in deep-space missions (e.g., Mars, asteroids). Third Cosmic Velocity : Enables interstellar exploration (e.g., Voyager 1 & 2). Understanding and optimizing for these velocities ensures cost-effective and technically feasible space missions. Every planetary mission, satellite launch, or interstellar probe relies on these fundamental velocity thresholds.","title":"Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 # Trajectories of a Freely Released Payload Near Earth Motivation When a payload is released from a spacecraft in orbit around Earth, its subsequent trajectory is governed by gravitational forces and its initial velocity and position. The object may re-enter Earth, remain in orbit, or escape into interplanetary space depending on its energy and direction. Analyzing these scenarios provides insights into orbital dynamics and mission planning. Fundamental Concepts Newton\u2019s Law of Universal Gravitation The force of gravity between Earth and the payload is: \\[ F = \\frac{G M m}{r^2} \\] Where: - \\(G = 6.67430 \\times 10^{-11}\\) m\u00b3/kg/s\u00b2 (gravitational constant) - \\(M\\) is the mass of Earth ( \\(5.972 \\times 10^{24}\\) kg) - \\(m\\) is the mass of the payload - \\(r\\) is the distance from Earth's center to the payload Gravitational Acceleration Acceleration due to gravity experienced by the payload is: \\[ \\vec{a} = -\\frac{G M}{r^3} \\vec{r} \\] This is a central force that always points toward the center of Earth. Energy-Based Classification of Trajectories The total mechanical energy \\(E\\) of the payload is the sum of kinetic and potential energy: \\[ E = \\frac{1}{2}mv^2 - \\frac{G M m}{r} \\] Depending on \\(E\\) , we classify the trajectory as: - Elliptical Orbit ( \\(E < 0\\) ): Bound orbit - Parabolic Trajectory ( \\(E = 0\\) ): Escape trajectory with minimum speed - Hyperbolic Trajectory ( \\(E > 0\\) ): Unbound escape trajectory The escape velocity at a distance \\(r\\) is: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2 G M}{r}} \\] Python Simulation: Numerical Integration of Trajectories import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 5.972e24 # kg (Earth) R = 6.371e6 # m (Earth radius) # Simulation parameters dt = 1.0 # seconds t_max = 20000 # total time steps = int(t_max / dt) # Initial position and velocity altitude = 300e3 # 300 km altitude r0 = np.array([R + altitude, 0]) v0 = np.array([0, 7800]) # m/s tangential velocity # Initialize arrays pos = np.zeros((steps, 2)) vel = np.zeros((steps, 2)) pos[0] = r0 vel[0] = v0 # Gravitational acceleration def acceleration(r): norm_r = np.linalg.norm(r) return -G * M * r / norm_r**3 # Euler integration for i in range(steps - 1): acc = acceleration(pos[i]) vel[i + 1] = vel[i] + acc * dt pos[i + 1] = pos[i] + vel[i + 1] * dt # Terminate if impact occurs if np.linalg.norm(pos[i + 1]) <= R: pos = pos[:i + 2] break # Plotting plt.figure(figsize=(8,8)) plt.plot(pos[:,0] / 1e3, pos[:,1] / 1e3, label='Payload Trajectory') # Draw Earth theta = np.linspace(0, 2*np.pi, 300) earth_x = R * np.cos(theta) / 1e3 earth_y = R * np.sin(theta) / 1e3 plt.plot(earth_x, earth_y, 'b', label='Earth') plt.xlabel('x (km)') plt.ylabel('y (km)') plt.title('Simulated Payload Trajectory Near Earth') plt.axis('equal') plt.grid(True) plt.legend() plt.show() Case Studies 1. Suborbital Re-entry If the payload velocity is too low, it follows a curved trajectory and returns to Earth. This is common in early ballistic missile flights and re-entry capsules. 2. Circular Orbit If velocity equals: \\[ v = \\sqrt{\\frac{G M}{r}} \\] The payload enters a circular orbit. This is how most satellites are initially inserted into low Earth orbit. 3. Elliptical Orbit A slightly higher or lower speed than the circular orbit velocity creates an elliptical orbit, with apogee and perigee. 4. Escape Trajectory If the payload exceeds escape velocity, it follows a parabolic or hyperbolic path, depending on the excess energy. Applications in Space Missions Satellite Deployment : Calculating correct release velocity ensures successful orbit. Re-entry Modules : Predicting descent paths improves safety and precision. Space Probes : Must achieve escape velocity for interplanetary missions. Orbital Maneuvers : Understanding how changes in velocity affect trajectory enables transfers (e.g., Hohmann transfer). Summary This detailed analysis and simulation illustrate how initial velocity and position determine a payload\u2019s trajectory. From orbital insertion to planetary escape, understanding the physics of motion near Earth is essential in aerospace design and mission execution. By adjusting these variables, we can achieve specific orbital goals or safely return payloads to Earth. Numerical simulation using Python allows us to model these scenarios precisely, opening pathways for deeper exploration of spaceflight dynamics.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"# Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When a payload is released from a spacecraft in orbit around Earth, its subsequent trajectory is governed by gravitational forces and its initial velocity and position. The object may re-enter Earth, remain in orbit, or escape into interplanetary space depending on its energy and direction. Analyzing these scenarios provides insights into orbital dynamics and mission planning.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#fundamental-concepts","text":"","title":"Fundamental Concepts"},{"location":"1%20Physics/2%20Gravity/Problem_3/#newtons-law-of-universal-gravitation","text":"The force of gravity between Earth and the payload is: \\[ F = \\frac{G M m}{r^2} \\] Where: - \\(G = 6.67430 \\times 10^{-11}\\) m\u00b3/kg/s\u00b2 (gravitational constant) - \\(M\\) is the mass of Earth ( \\(5.972 \\times 10^{24}\\) kg) - \\(m\\) is the mass of the payload - \\(r\\) is the distance from Earth's center to the payload","title":"Newton\u2019s Law of Universal Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#gravitational-acceleration","text":"Acceleration due to gravity experienced by the payload is: \\[ \\vec{a} = -\\frac{G M}{r^3} \\vec{r} \\] This is a central force that always points toward the center of Earth.","title":"Gravitational Acceleration"},{"location":"1%20Physics/2%20Gravity/Problem_3/#energy-based-classification-of-trajectories","text":"The total mechanical energy \\(E\\) of the payload is the sum of kinetic and potential energy: \\[ E = \\frac{1}{2}mv^2 - \\frac{G M m}{r} \\] Depending on \\(E\\) , we classify the trajectory as: - Elliptical Orbit ( \\(E < 0\\) ): Bound orbit - Parabolic Trajectory ( \\(E = 0\\) ): Escape trajectory with minimum speed - Hyperbolic Trajectory ( \\(E > 0\\) ): Unbound escape trajectory The escape velocity at a distance \\(r\\) is: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2 G M}{r}} \\]","title":"Energy-Based Classification of Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-simulation-numerical-integration-of-trajectories","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 5.972e24 # kg (Earth) R = 6.371e6 # m (Earth radius) # Simulation parameters dt = 1.0 # seconds t_max = 20000 # total time steps = int(t_max / dt) # Initial position and velocity altitude = 300e3 # 300 km altitude r0 = np.array([R + altitude, 0]) v0 = np.array([0, 7800]) # m/s tangential velocity # Initialize arrays pos = np.zeros((steps, 2)) vel = np.zeros((steps, 2)) pos[0] = r0 vel[0] = v0 # Gravitational acceleration def acceleration(r): norm_r = np.linalg.norm(r) return -G * M * r / norm_r**3 # Euler integration for i in range(steps - 1): acc = acceleration(pos[i]) vel[i + 1] = vel[i] + acc * dt pos[i + 1] = pos[i] + vel[i + 1] * dt # Terminate if impact occurs if np.linalg.norm(pos[i + 1]) <= R: pos = pos[:i + 2] break # Plotting plt.figure(figsize=(8,8)) plt.plot(pos[:,0] / 1e3, pos[:,1] / 1e3, label='Payload Trajectory') # Draw Earth theta = np.linspace(0, 2*np.pi, 300) earth_x = R * np.cos(theta) / 1e3 earth_y = R * np.sin(theta) / 1e3 plt.plot(earth_x, earth_y, 'b', label='Earth') plt.xlabel('x (km)') plt.ylabel('y (km)') plt.title('Simulated Payload Trajectory Near Earth') plt.axis('equal') plt.grid(True) plt.legend() plt.show()","title":"Python Simulation: Numerical Integration of Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_3/#case-studies","text":"","title":"Case Studies"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-suborbital-re-entry","text":"If the payload velocity is too low, it follows a curved trajectory and returns to Earth. This is common in early ballistic missile flights and re-entry capsules.","title":"1. Suborbital Re-entry"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-circular-orbit","text":"If velocity equals: \\[ v = \\sqrt{\\frac{G M}{r}} \\] The payload enters a circular orbit. This is how most satellites are initially inserted into low Earth orbit.","title":"2. Circular Orbit"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-elliptical-orbit","text":"A slightly higher or lower speed than the circular orbit velocity creates an elliptical orbit, with apogee and perigee.","title":"3. Elliptical Orbit"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-escape-trajectory","text":"If the payload exceeds escape velocity, it follows a parabolic or hyperbolic path, depending on the excess energy.","title":"4. Escape Trajectory"},{"location":"1%20Physics/2%20Gravity/Problem_3/#applications-in-space-missions","text":"Satellite Deployment : Calculating correct release velocity ensures successful orbit. Re-entry Modules : Predicting descent paths improves safety and precision. Space Probes : Must achieve escape velocity for interplanetary missions. Orbital Maneuvers : Understanding how changes in velocity affect trajectory enables transfers (e.g., Hohmann transfer).","title":"Applications in Space Missions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#summary","text":"This detailed analysis and simulation illustrate how initial velocity and position determine a payload\u2019s trajectory. From orbital insertion to planetary escape, understanding the physics of motion near Earth is essential in aerospace design and mission execution. By adjusting these variables, we can achieve specific orbital goals or safely return payloads to Earth. Numerical simulation using Python allows us to model these scenarios precisely, opening pathways for deeper exploration of spaceflight dynamics.","title":"Summary"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Interference Patterns on a Water Surface Motivation Wave interference is a fundamental phenomenon where two or more waves overlap in space, leading to a new wave pattern. On a water surface, this is elegantly demonstrated when ripples from different points meet. Their superposition produces a pattern of reinforcement (constructive interference) and cancellation (destructive interference). These patterns not only provide visual insight into the physics of waves but also model various real-world phenomena including sound, light, and radio wave interactions. This project aims to visualize interference using wave sources placed at the vertices of a regular polygon. The symmetry and spacing of these sources produce rich interference patterns. Theoretical Background Single Point Source Wave The displacement \\((\\eta(x, y, t)\\) ) on the surface of the water from a point source at position \\(((x_0, y_0)\\) ) is modeled by: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cos(kr - \\omega t + \\phi) \\] Where: - \\((A\\) ): Amplitude of the wave - \\((r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) ): Distance from source to point \\(((x, y)\\) ) - \\((k = \\frac{2\\pi}{\\lambda}\\) ): Wave number - \\((\\lambda\\) ): Wavelength - \\((\\omega = 2\\pi f\\) ): Angular frequency - \\((f\\) ): Frequency - \\((\\phi\\) ): Initial phase - \\((t\\) ): Time Superposition Principle With multiple coherent sources emitting waves of equal frequency and amplitude, the net displacement is the sum of all individual displacements: \\[ \\eta_{sum}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] Where \\((N\\) ) is the number of wave sources. Simulation Setup 1. Define Parameters Number of sources \\((N\\) ): Vertices of the polygon Radius \\((R\\) ): Distance from polygon center to each source Grid size: Area of simulation in the \\((xy\\) )-plane 2. Create Wave Sources Sources are placed symmetrically around the origin using trigonometric functions. 3. Calculate Wave Contributions Use the distance formula for \\((r\\) ) Sum all contributions to get \\((\\eta_{sum}\\) ) 4. Visualization Use contour plots to show high and low displacement regions Python Code import numpy as np import matplotlib.pyplot as plt # === Wave Parameters === A = 1.0 # Amplitude wavelength = 2.0 # Wavelength (lambda) f = 1.0 # Frequency (Hz) omega = 2 * np.pi * f k = 2 * np.pi / wavelength phi = 0 # Initial phase t = 0.0 # Snapshot at t seconds # === Polygon Configuration === N = 4 # Number of sources (3=triangle, 4=square, etc.) R = 5.0 # Radius from center to vertex # === Grid Setup === x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) # === Source Coordinates === sources = [] for i in range(N): angle = 2 * np.pi * i / N x0 = R * np.cos(angle) y0 = R * np.sin(angle) sources.append((x0, y0)) # === Wave Superposition === eta_sum = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) eta = A / np.sqrt(r + 1e-6) * np.cos(k * r - omega * t + phi) eta_sum += eta # === Plotting === plt.figure(figsize=(10, 8)) contour = plt.contourf(X, Y, eta_sum, levels=150, cmap='RdBu') plt.colorbar(contour, label='Wave Displacement') plt.title(f\"Interference Pattern: {N}-Vertex Regular Polygon\") plt.xlabel('x (units)') plt.ylabel('y (units)') plt.axis('equal') plt.grid(False) plt.show() Observations and Analysis Constructive Interference Occurs at points where waves from all sources arrive in phase . Results in amplified displacement . Destructive Interference Occurs at points where waves arrive out of phase . Results in cancellation or reduced displacement. Symmetry and Patterns The rotational symmetry of the polygon is reflected in the interference pattern. As \\((N\\) ) increases, the pattern becomes more circular and complex. Possible Extensions Animation over time to show wave propagation Different phase shifts between sources Changing polygon types : triangle (N=3), pentagon (N=5), hexagon (N=6) Interactive UI using sliders for real-time parameter adjustment (with Jupyter widgets or Streamlit) Conclusion This simulation visually demonstrates how regular spatial arrangements of coherent wave sources lead to predictable and beautiful interference patterns. The combination of theory and Python simulation provides a hands-on approach to mastering wave behavior and superposition.","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Wave interference is a fundamental phenomenon where two or more waves overlap in space, leading to a new wave pattern. On a water surface, this is elegantly demonstrated when ripples from different points meet. Their superposition produces a pattern of reinforcement (constructive interference) and cancellation (destructive interference). These patterns not only provide visual insight into the physics of waves but also model various real-world phenomena including sound, light, and radio wave interactions. This project aims to visualize interference using wave sources placed at the vertices of a regular polygon. The symmetry and spacing of these sources produce rich interference patterns.","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#theoretical-background","text":"","title":"Theoretical Background"},{"location":"1%20Physics/3%20Waves/Problem_1/#single-point-source-wave","text":"The displacement \\((\\eta(x, y, t)\\) ) on the surface of the water from a point source at position \\(((x_0, y_0)\\) ) is modeled by: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cos(kr - \\omega t + \\phi) \\] Where: - \\((A\\) ): Amplitude of the wave - \\((r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) ): Distance from source to point \\(((x, y)\\) ) - \\((k = \\frac{2\\pi}{\\lambda}\\) ): Wave number - \\((\\lambda\\) ): Wavelength - \\((\\omega = 2\\pi f\\) ): Angular frequency - \\((f\\) ): Frequency - \\((\\phi\\) ): Initial phase - \\((t\\) ): Time","title":"Single Point Source Wave"},{"location":"1%20Physics/3%20Waves/Problem_1/#superposition-principle","text":"With multiple coherent sources emitting waves of equal frequency and amplitude, the net displacement is the sum of all individual displacements: \\[ \\eta_{sum}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] Where \\((N\\) ) is the number of wave sources.","title":"Superposition Principle"},{"location":"1%20Physics/3%20Waves/Problem_1/#simulation-setup","text":"","title":"Simulation Setup"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-define-parameters","text":"Number of sources \\((N\\) ): Vertices of the polygon Radius \\((R\\) ): Distance from polygon center to each source Grid size: Area of simulation in the \\((xy\\) )-plane","title":"1. Define Parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-create-wave-sources","text":"Sources are placed symmetrically around the origin using trigonometric functions.","title":"2. Create Wave Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-calculate-wave-contributions","text":"Use the distance formula for \\((r\\) ) Sum all contributions to get \\((\\eta_{sum}\\) )","title":"3. Calculate Wave Contributions"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-visualization","text":"Use contour plots to show high and low displacement regions","title":"4. Visualization"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-code","text":"import numpy as np import matplotlib.pyplot as plt # === Wave Parameters === A = 1.0 # Amplitude wavelength = 2.0 # Wavelength (lambda) f = 1.0 # Frequency (Hz) omega = 2 * np.pi * f k = 2 * np.pi / wavelength phi = 0 # Initial phase t = 0.0 # Snapshot at t seconds # === Polygon Configuration === N = 4 # Number of sources (3=triangle, 4=square, etc.) R = 5.0 # Radius from center to vertex # === Grid Setup === x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) # === Source Coordinates === sources = [] for i in range(N): angle = 2 * np.pi * i / N x0 = R * np.cos(angle) y0 = R * np.sin(angle) sources.append((x0, y0)) # === Wave Superposition === eta_sum = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) eta = A / np.sqrt(r + 1e-6) * np.cos(k * r - omega * t + phi) eta_sum += eta # === Plotting === plt.figure(figsize=(10, 8)) contour = plt.contourf(X, Y, eta_sum, levels=150, cmap='RdBu') plt.colorbar(contour, label='Wave Displacement') plt.title(f\"Interference Pattern: {N}-Vertex Regular Polygon\") plt.xlabel('x (units)') plt.ylabel('y (units)') plt.axis('equal') plt.grid(False) plt.show()","title":"Python Code"},{"location":"1%20Physics/3%20Waves/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/3%20Waves/Problem_1/#observations-and-analysis","text":"","title":"Observations and Analysis"},{"location":"1%20Physics/3%20Waves/Problem_1/#constructive-interference","text":"Occurs at points where waves from all sources arrive in phase . Results in amplified displacement .","title":"Constructive Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#destructive-interference","text":"Occurs at points where waves arrive out of phase . Results in cancellation or reduced displacement.","title":"Destructive Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#symmetry-and-patterns","text":"The rotational symmetry of the polygon is reflected in the interference pattern. As \\((N\\) ) increases, the pattern becomes more circular and complex.","title":"Symmetry and Patterns"},{"location":"1%20Physics/3%20Waves/Problem_1/#possible-extensions","text":"Animation over time to show wave propagation Different phase shifts between sources Changing polygon types : triangle (N=3), pentagon (N=5), hexagon (N=6) Interactive UI using sliders for real-time parameter adjustment (with Jupyter widgets or Streamlit)","title":"Possible Extensions"},{"location":"1%20Physics/3%20Waves/Problem_1/#conclusion","text":"This simulation visually demonstrates how regular spatial arrangements of coherent wave sources lead to predictable and beautiful interference patterns. The combination of theory and Python simulation provides a hands-on approach to mastering wave behavior and superposition.","title":"Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Lorentz Force Simulation 1. Motivation The Lorentz force governs the motion of charged particles under electric and magnetic fields: \\[ \\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] It plays a crucial role in: - Particle accelerators - Plasma confinement systems (e.g., Tokamaks) - Mass spectrometers - Cosmic ray dynamics 2. Applications of the Lorentz Force Particle Accelerators : Use magnetic fields to bend charged particles into circular paths. Mass Spectrometry : Employs both electric and magnetic fields to separate ions by mass-to-charge ratio. Plasma Confinement : Magnetic fields trap hot plasma to maintain fusion conditions. Auroras and Cosmic Rays : Natural examples of charged particles interacting with Earth's magnetic field. 3. Simulation Overview We simulate the motion of a charged particle using numerical integration. We explore: - Uniform magnetic field - Combined electric and magnetic fields - Crossed fields (orthogonal \\(\\mathbf{E}\\) and \\(\\mathbf{B}\\) ) 4. Python Code import numpy as np import matplotlib.pyplot as plt # Constants q = 1.0 # charge (C) m = 1.0 # mass (kg) B = np.array([0, 0, 1.0]) # uniform magnetic field (T) E = np.array([0.0, 0.0, 0.0]) # electric field (V/m) # Initial state r0 = np.array([0.0, 0.0, 0.0]) # position (m) v0 = np.array([1.0, 1.0, 0.0]) # velocity (m/s) # Time parameters dt = 0.01 T = 10 steps = int(T / dt) # Arrays to store data positions = np.zeros((steps, 3)) velocities = np.zeros((steps, 3)) positions[0] = r0 velocities[0] = v0 # Euler integration for i in range(steps - 1): v = velocities[i] F = q * (E + np.cross(v, B)) a = F / m velocities[i+1] = v + a * dt positions[i+1] = positions[i] + velocities[i+1] * dt # Plot trajectory fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:, 0], positions[:, 1], positions[:, 2]) ax.set_title(\"Particle Trajectory in a Uniform Magnetic Field\") ax.set_xlabel(\"x (m)\") ax.set_ylabel(\"y (m)\") ax.set_zlabel(\"z (m)\") plt.show() 5. Observations In a uniform magnetic field , the particle follows a circular or helical path depending on the initial velocity. The radius of the circular motion (Larmor radius) is: \\[ r_L = \\frac{mv_{\\perp}}{qB} \\] With an electric field present, drift motion occurs: \\[ \\mathbf{v}_d = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} \\] 6. Extensions Introduce non-uniform fields : \\(\\mathbf{B}(x, y, z)\\) and/or \\(\\mathbf{E}(x, y, z)\\) . Use Runge-Kutta methods for improved accuracy. Add relativistic corrections for high-speed particles. Simulate multiple particles for beam dynamics or collective effects.","title":"Lorentz Force Simulation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#lorentz-force-simulation","text":"","title":"Lorentz Force Simulation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-motivation","text":"The Lorentz force governs the motion of charged particles under electric and magnetic fields: \\[ \\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] It plays a crucial role in: - Particle accelerators - Plasma confinement systems (e.g., Tokamaks) - Mass spectrometers - Cosmic ray dynamics","title":"1. Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-applications-of-the-lorentz-force","text":"Particle Accelerators : Use magnetic fields to bend charged particles into circular paths. Mass Spectrometry : Employs both electric and magnetic fields to separate ions by mass-to-charge ratio. Plasma Confinement : Magnetic fields trap hot plasma to maintain fusion conditions. Auroras and Cosmic Rays : Natural examples of charged particles interacting with Earth's magnetic field.","title":"2. Applications of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-simulation-overview","text":"We simulate the motion of a charged particle using numerical integration. We explore: - Uniform magnetic field - Combined electric and magnetic fields - Crossed fields (orthogonal \\(\\mathbf{E}\\) and \\(\\mathbf{B}\\) )","title":"3. Simulation Overview"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-python-code","text":"import numpy as np import matplotlib.pyplot as plt # Constants q = 1.0 # charge (C) m = 1.0 # mass (kg) B = np.array([0, 0, 1.0]) # uniform magnetic field (T) E = np.array([0.0, 0.0, 0.0]) # electric field (V/m) # Initial state r0 = np.array([0.0, 0.0, 0.0]) # position (m) v0 = np.array([1.0, 1.0, 0.0]) # velocity (m/s) # Time parameters dt = 0.01 T = 10 steps = int(T / dt) # Arrays to store data positions = np.zeros((steps, 3)) velocities = np.zeros((steps, 3)) positions[0] = r0 velocities[0] = v0 # Euler integration for i in range(steps - 1): v = velocities[i] F = q * (E + np.cross(v, B)) a = F / m velocities[i+1] = v + a * dt positions[i+1] = positions[i] + velocities[i+1] * dt # Plot trajectory fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:, 0], positions[:, 1], positions[:, 2]) ax.set_title(\"Particle Trajectory in a Uniform Magnetic Field\") ax.set_xlabel(\"x (m)\") ax.set_ylabel(\"y (m)\") ax.set_zlabel(\"z (m)\") plt.show()","title":"4. Python Code"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#5-observations","text":"In a uniform magnetic field , the particle follows a circular or helical path depending on the initial velocity. The radius of the circular motion (Larmor radius) is: \\[ r_L = \\frac{mv_{\\perp}}{qB} \\] With an electric field present, drift motion occurs: \\[ \\mathbf{v}_d = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} \\]","title":"5. Observations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#6-extensions","text":"Introduce non-uniform fields : \\(\\mathbf{B}(x, y, z)\\) and/or \\(\\mathbf{E}(x, y, z)\\) . Use Runge-Kutta methods for improved accuracy. Add relativistic corrections for high-speed particles. Simulate multiple particles for beam dynamics or collective effects.","title":"6. Extensions"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Equivalent Resistance Using Graph Theory 1. Motivation Calculating equivalent resistance is essential in understanding electrical networks. Traditional methods using series-parallel simplifications become tedious for complex circuits. Graph theory offers a powerful algorithmic alternative by modeling circuits as weighted graphs: - Nodes represent junctions. - Edges represent resistors with weights equal to resistance values. This enables programmatic simplification and analysis of even complex resistor networks. 2. Algorithm Overview We simplify the circuit using two rules: 1. Series combination : If a node has exactly two neighbors, the resistors can be merged. 2. Parallel combination : If multiple edges exist between two nodes, combine them via: $$ \\frac{1}{R_{\\text{eq}}} = \\sum_i \\frac{1}{R_i} $$ The process is repeated until a single edge (equivalent resistance) remains between the source and target. 3. Pseudocode function simplify_graph(graph, source, target): repeat: for each node N in graph: if N is not source or target and degree(N) == 2: merge series resistors at N for each pair of nodes (A, B) with multiple edges: merge them in parallel until no further simplifications return weight of edge between source and target 4. Python Implementation import networkx as nx def parallel_merge(G, u, v): resistances = [1 / G[u][v][key]['resistance'] for key in G[u][v]] R_eq = 1 / sum(resistances) G.remove_edges_from([(u, v, key) for key in list(G[u][v].keys())]) G.add_edge(u, v, resistance=R_eq) def series_merge(G, node): neighbors = list(G.neighbors(node)) u, v = neighbors[0], neighbors[1] R1 = list(G[u][node].values())[0]['resistance'] R2 = list(G[v][node].values())[0]['resistance'] R_eq = R1 + R2 G.remove_node(node) G.add_edge(u, v, resistance=R_eq) def simplify_circuit(G, source, target): changed = True while changed: changed = False for node in list(G.nodes): if node not in (source, target) and G.degree[node] == 2: series_merge(G, node) changed = True break for u, v in list(G.edges()): if G.number_of_edges(u, v) > 1: parallel_merge(G, u, v) changed = True break return G[source][target]['resistance'] # Example usage G = nx.MultiGraph() G.add_edge('A', 'B', resistance=2) G.add_edge('B', 'C', resistance=3) G.add_edge('C', 'D', resistance=4) G.add_edge('A', 'D', resistance=6) # Parallel with path A-B-C-D result = simplify_circuit(G, 'A', 'D') print(f\"Equivalent Resistance between A and D: {result} ohms\") 5. Example Circuit Series : A\u2013B\u2013C with resistors 2\u03a9, 3\u03a9 $$ R_{\\text{eq}} = 2 + 3 = 5\\ \\Omega $$ Parallel : Two 6\u03a9 resistors $$ R_{\\text{eq}} = \\left(\\frac{1}{6} + \\frac{1}{6}\\right)^{-1} = 3\\ \\Omega $$ 6. Efficiency & Improvements Current implementation uses repeated iteration , which can be optimized. DFS or Union-Find structures can speed up recognition of connected components and cycles. Can extend to support voltage source modeling , current flow , and nonlinear elements . 7. Extensions Add visualization using matplotlib and networkx.draw() . Export to SPICE-compatible netlists. Integrate with Falstad or simulation environments.","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-motivation","text":"Calculating equivalent resistance is essential in understanding electrical networks. Traditional methods using series-parallel simplifications become tedious for complex circuits. Graph theory offers a powerful algorithmic alternative by modeling circuits as weighted graphs: - Nodes represent junctions. - Edges represent resistors with weights equal to resistance values. This enables programmatic simplification and analysis of even complex resistor networks.","title":"1. Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-algorithm-overview","text":"We simplify the circuit using two rules: 1. Series combination : If a node has exactly two neighbors, the resistors can be merged. 2. Parallel combination : If multiple edges exist between two nodes, combine them via: $$ \\frac{1}{R_{\\text{eq}}} = \\sum_i \\frac{1}{R_i} $$ The process is repeated until a single edge (equivalent resistance) remains between the source and target.","title":"2. Algorithm Overview"},{"location":"1%20Physics/5%20Circuits/Problem_1/#3-pseudocode","text":"function simplify_graph(graph, source, target): repeat: for each node N in graph: if N is not source or target and degree(N) == 2: merge series resistors at N for each pair of nodes (A, B) with multiple edges: merge them in parallel until no further simplifications return weight of edge between source and target","title":"3. Pseudocode"},{"location":"1%20Physics/5%20Circuits/Problem_1/#4-python-implementation","text":"import networkx as nx def parallel_merge(G, u, v): resistances = [1 / G[u][v][key]['resistance'] for key in G[u][v]] R_eq = 1 / sum(resistances) G.remove_edges_from([(u, v, key) for key in list(G[u][v].keys())]) G.add_edge(u, v, resistance=R_eq) def series_merge(G, node): neighbors = list(G.neighbors(node)) u, v = neighbors[0], neighbors[1] R1 = list(G[u][node].values())[0]['resistance'] R2 = list(G[v][node].values())[0]['resistance'] R_eq = R1 + R2 G.remove_node(node) G.add_edge(u, v, resistance=R_eq) def simplify_circuit(G, source, target): changed = True while changed: changed = False for node in list(G.nodes): if node not in (source, target) and G.degree[node] == 2: series_merge(G, node) changed = True break for u, v in list(G.edges()): if G.number_of_edges(u, v) > 1: parallel_merge(G, u, v) changed = True break return G[source][target]['resistance'] # Example usage G = nx.MultiGraph() G.add_edge('A', 'B', resistance=2) G.add_edge('B', 'C', resistance=3) G.add_edge('C', 'D', resistance=4) G.add_edge('A', 'D', resistance=6) # Parallel with path A-B-C-D result = simplify_circuit(G, 'A', 'D') print(f\"Equivalent Resistance between A and D: {result} ohms\")","title":"4. Python Implementation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#5-example-circuit","text":"Series : A\u2013B\u2013C with resistors 2\u03a9, 3\u03a9 $$ R_{\\text{eq}} = 2 + 3 = 5\\ \\Omega $$ Parallel : Two 6\u03a9 resistors $$ R_{\\text{eq}} = \\left(\\frac{1}{6} + \\frac{1}{6}\\right)^{-1} = 3\\ \\Omega $$","title":"5. Example Circuit"},{"location":"1%20Physics/5%20Circuits/Problem_1/#6-efficiency-improvements","text":"Current implementation uses repeated iteration , which can be optimized. DFS or Union-Find structures can speed up recognition of connected components and cycles. Can extend to support voltage source modeling , current flow , and nonlinear elements .","title":"6. Efficiency &amp; Improvements"},{"location":"1%20Physics/5%20Circuits/Problem_1/#7-extensions","text":"Add visualization using matplotlib and networkx.draw() . Export to SPICE-compatible netlists. Integrate with Falstad or simulation environments.","title":"7. Extensions"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Central Limit Theorem (CLT): A Comprehensive Exploration Through Simulation Motivation The Central Limit Theorem (CLT) is one of the most fundamental results in probability theory and statistics. It states that: Given a population with any distribution having a finite mean \\(\\mu\\) and finite variance \\(\\sigma^2\\) , the distribution of the sample means approaches a normal distribution as the sample size \\(n\\) increases. This theorem is the theoretical justification for using normal distributions in a wide variety of real-world statistical applications \u2014 even when the underlying data are not normally distributed. Theoretical Background Formal Statement Let \\(X_1, X_2, ..., X_n\\) be a sequence of i.i.d. random variables with mean \\(\\mu\\) and variance \\(\\sigma^2\\) . Define the sample mean: \\[ \\bar{X}_n = \\frac{1}{n} \\sum_{i=1}^{n} X_i \\] Then, as \\(n \\to \\infty\\) , \\[ \\frac{\\bar{X}_n - \\mu}{\\sigma / \\sqrt{n}} \\xrightarrow{d} \\mathcal{N}(0, 1) \\] That is, the standardized sample mean converges in distribution to a standard normal distribution. \ud83d\udccf Key Concepts Convergence in Distribution : The distribution of \\(\\bar{X}_n\\) gets closer to a normal distribution as \\(n\\) increases. Sampling Distribution : The probability distribution of a sample statistic (like the mean) taken from many samples. Standard Error : The standard deviation of the sampling distribution of the mean: $$ \\text{SE} = \\frac{\\sigma}{\\sqrt{n}} $$ Step 1: Population Distributions We will generate synthetic data from three different distributions: Uniform(0,1) : All values between 0 and 1 are equally likely. Exponential(\u03bb=1) : Skewed right, models waiting times. Binomial(n=10, p=0.5) : Discrete distribution modeling number of successes in trials. Step 2: Sampling and Visualization For each distribution: Generate a large population (100,000 values) Sample from the population using sizes \\(n = 5, 10, 30, 50\\) Repeat 10,000 times for each sample size Plot histograms of sample means We will observe how the shape of the sampling distribution changes with sample size . Step 3: Parameter Exploration Effect of Sample Size As \\(n\\) increases: The sampling distribution becomes more symmetric and bell-shaped The variance of sample means decreases: $$ \\text{Var}(\\bar{X}_n) = \\frac{\\sigma^2}{n} $$ Effect of Population Distribution Populations with higher skewness (e.g., exponential) require larger sample sizes to approximate normality. Discrete or multimodal populations may also take longer to converge. Python Code for Simulation import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Set plotting style sns.set(style=\"whitegrid\") # Define population distributions distributions = { \"Uniform(0,1)\": lambda size: np.random.uniform(0, 1, size), \"Exponential(\u03bb=1)\": lambda size: np.random.exponential(1, size), \"Binomial(n=10, p=0.5)\": lambda size: np.random.binomial(10, 0.5, size) } sample_sizes = [5, 10, 30, 50] num_samples = 10000 population_size = 100000 for dist_name, generator in distributions.items(): print(f\"\\nSampling from: {dist_name}\") population = generator(population_size) fig, axes = plt.subplots(1, len(sample_sizes), figsize=(20, 4), sharey=True) fig.suptitle(f\"Sampling Distribution of Sample Means\\n{dist_name}\", fontsize=16) for i, n in enumerate(sample_sizes): means = [ np.mean(np.random.choice(population, size=n, replace=False)) for _ in range(num_samples) ] sns.histplot(means, bins=40, kde=True, ax=axes[i], color='skyblue') axes[i].set_title(f\"Sample Size n = {n}\") axes[i].set_xlabel(\"Sample Mean\") if i == 0: axes[i].set_ylabel(\"Frequency\") plt.tight_layout(rect=[0, 0, 1, 0.95]) plt.show()","title":"Central Limit Theorem (CLT): A Comprehensive Exploration Through Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#central-limit-theorem-clt-a-comprehensive-exploration-through-simulation","text":"","title":"Central Limit Theorem (CLT): A Comprehensive Exploration Through Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#motivation","text":"The Central Limit Theorem (CLT) is one of the most fundamental results in probability theory and statistics. It states that: Given a population with any distribution having a finite mean \\(\\mu\\) and finite variance \\(\\sigma^2\\) , the distribution of the sample means approaches a normal distribution as the sample size \\(n\\) increases. This theorem is the theoretical justification for using normal distributions in a wide variety of real-world statistical applications \u2014 even when the underlying data are not normally distributed.","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#theoretical-background","text":"","title":"Theoretical Background"},{"location":"1%20Physics/6%20Statistics/Problem_1/#formal-statement","text":"Let \\(X_1, X_2, ..., X_n\\) be a sequence of i.i.d. random variables with mean \\(\\mu\\) and variance \\(\\sigma^2\\) . Define the sample mean: \\[ \\bar{X}_n = \\frac{1}{n} \\sum_{i=1}^{n} X_i \\] Then, as \\(n \\to \\infty\\) , \\[ \\frac{\\bar{X}_n - \\mu}{\\sigma / \\sqrt{n}} \\xrightarrow{d} \\mathcal{N}(0, 1) \\] That is, the standardized sample mean converges in distribution to a standard normal distribution.","title":"Formal Statement"},{"location":"1%20Physics/6%20Statistics/Problem_1/#key-concepts","text":"Convergence in Distribution : The distribution of \\(\\bar{X}_n\\) gets closer to a normal distribution as \\(n\\) increases. Sampling Distribution : The probability distribution of a sample statistic (like the mean) taken from many samples. Standard Error : The standard deviation of the sampling distribution of the mean: $$ \\text{SE} = \\frac{\\sigma}{\\sqrt{n}} $$","title":"\ud83d\udccf Key Concepts"},{"location":"1%20Physics/6%20Statistics/Problem_1/#step-1-population-distributions","text":"We will generate synthetic data from three different distributions: Uniform(0,1) : All values between 0 and 1 are equally likely. Exponential(\u03bb=1) : Skewed right, models waiting times. Binomial(n=10, p=0.5) : Discrete distribution modeling number of successes in trials.","title":"Step 1: Population Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#step-2-sampling-and-visualization","text":"For each distribution: Generate a large population (100,000 values) Sample from the population using sizes \\(n = 5, 10, 30, 50\\) Repeat 10,000 times for each sample size Plot histograms of sample means We will observe how the shape of the sampling distribution changes with sample size .","title":"Step 2: Sampling and Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_1/#step-3-parameter-exploration","text":"","title":"Step 3: Parameter Exploration"},{"location":"1%20Physics/6%20Statistics/Problem_1/#effect-of-sample-size","text":"As \\(n\\) increases: The sampling distribution becomes more symmetric and bell-shaped The variance of sample means decreases: $$ \\text{Var}(\\bar{X}_n) = \\frac{\\sigma^2}{n} $$","title":"Effect of Sample Size"},{"location":"1%20Physics/6%20Statistics/Problem_1/#effect-of-population-distribution","text":"Populations with higher skewness (e.g., exponential) require larger sample sizes to approximate normality. Discrete or multimodal populations may also take longer to converge.","title":"Effect of Population Distribution"},{"location":"1%20Physics/6%20Statistics/Problem_1/#python-code-for-simulation","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Set plotting style sns.set(style=\"whitegrid\") # Define population distributions distributions = { \"Uniform(0,1)\": lambda size: np.random.uniform(0, 1, size), \"Exponential(\u03bb=1)\": lambda size: np.random.exponential(1, size), \"Binomial(n=10, p=0.5)\": lambda size: np.random.binomial(10, 0.5, size) } sample_sizes = [5, 10, 30, 50] num_samples = 10000 population_size = 100000 for dist_name, generator in distributions.items(): print(f\"\\nSampling from: {dist_name}\") population = generator(population_size) fig, axes = plt.subplots(1, len(sample_sizes), figsize=(20, 4), sharey=True) fig.suptitle(f\"Sampling Distribution of Sample Means\\n{dist_name}\", fontsize=16) for i, n in enumerate(sample_sizes): means = [ np.mean(np.random.choice(population, size=n, replace=False)) for _ in range(num_samples) ] sns.histplot(means, bins=40, kde=True, ax=axes[i], color='skyblue') axes[i].set_title(f\"Sample Size n = {n}\") axes[i].set_xlabel(\"Sample Mean\") if i == 0: axes[i].set_ylabel(\"Frequency\") plt.tight_layout(rect=[0, 0, 1, 0.95]) plt.show()","title":"Python Code for Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Estimating \\(\\pi\\) Using Monte Carlo Methods Part 1: Circle-Based Monte Carlo Simulation 1. Theoretical Foundation The idea is based on comparing the area of a unit circle (radius = 1) with the area of a square that bounds it. Area of the unit circle: \\(A_{\\text{circle}} = \\pi r^2 = \\pi\\) Area of the square: \\(A_{\\text{square}} = (2r)^2 = 4\\) Random points are uniformly distributed in the square. The ratio of points that fall inside the circle to the total number of points approximates the ratio of the areas: \\[ \\frac{\\text{points inside circle}}{\\text{total points}} \\approx \\frac{\\pi}{4} \\] Thus, we can estimate \\(\\pi\\) using: \\[ \\pi \\approx 4 \\cdot \\frac{\\text{points inside circle}}{\\text{total points}} \\] 2. Python Simulation (Circle Method) import numpy as np import matplotlib.pyplot as plt def estimate_pi_circle(n_points): x = np.random.uniform(-1, 1, n_points) y = np.random.uniform(-1, 1, n_points) inside_circle = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside_circle) / n_points # Visualization plt.figure(figsize=(6,6)) plt.scatter(x[inside_circle], y[inside_circle], s=1, color='blue', label='Inside Circle') plt.scatter(x[~inside_circle], y[~inside_circle], s=1, color='red', label='Outside Circle') circle = plt.Circle((0, 0), 1, fill=False, color='black', linestyle='--') plt.gca().add_artist(circle) plt.title(f\"Monte Carlo Pi Estimate: {pi_estimate:.5f}\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.axis('equal') plt.legend() plt.grid(True) plt.show() return pi_estimate # Example usage estimate_pi_circle(10000) Part 2: Buffon's Needle Simulation 1. Theoretical Foundation Buffon's Needle problem involves dropping a needle of length \\(L\\) onto a floor with parallel lines spaced distance \\(D\\) apart. If \\(L \\leq D\\) , the probability \\(P\\) that the needle crosses a line is: \\[ P = \\frac{2L}{\\pi D} \\] Rearranging gives an estimate for \\(\\pi\\) : \\[ \\pi \\approx \\frac{2L \\cdot N}{D \\cdot C} \\] Where: - \\(N\\) = total needle drops - \\(C\\) = number of crossings 2. Python Simulation (Buffon's Needle) import numpy as np import matplotlib.pyplot as plt def estimate_pi_buffon(n_drops, needle_length=1.0, line_distance=2.0): assert needle_length <= line_distance, \"Needle length must be <= line spacing\" # Randomly generate needle centers and angles centers = np.random.uniform(0, line_distance / 2, n_drops) angles = np.random.uniform(0, np.pi / 2, n_drops) crosses = centers <= (needle_length / 2) * np.sin(angles) # Estimate pi n_crosses = np.sum(crosses) if n_crosses == 0: return None # Avoid division by zero pi_estimate = (2 * needle_length * n_drops) / (line_distance * n_crosses) # Visualization plt.figure(figsize=(6,6)) for i in range(100): x0 = np.random.uniform(0, 10) y0 = np.random.uniform(0, 10) theta = np.random.uniform(0, 2 * np.pi) x1 = x0 + (needle_length / 2) * np.cos(theta) x2 = x0 - (needle_length / 2) * np.cos(theta) y1 = y0 + (needle_length / 2) * np.sin(theta) y2 = y0 - (needle_length / 2) * np.sin(theta) plt.plot([x1, x2], [y1, y2], 'r-' if abs(y1 - y2) > line_distance else 'b-') for i in range(0, 11): plt.axhline(i, color='black', linestyle='--', linewidth=0.5) plt.title(f\"Buffon's Needle Pi Estimate: {pi_estimate:.5f}\") plt.xlim(0, 10) plt.ylim(0, 10) plt.gca().set_aspect('equal') plt.show() return pi_estimate # Example usage estimate_pi_buffon(10000) Part 3: Convergence and Analysis As the number of iterations ( \\(N\\) ) increases, the estimates for \\(\\pi\\) from both methods converge toward the true value. Circle-based estimation usually converges faster and is simpler to implement. Summary Comparison Table Method Formula Used Convergence Rate Visualization Simplicity Accuracy (for large \\(N\\) ) Circle Method \\(\\pi \\approx 4 \\cdot \\frac{\\text{inside}}{\\text{total}}\\) Fast High High Buffon's Needle \\(\\pi \\approx \\frac{2L \\cdot N}{D \\cdot C}\\) Slow Moderate Moderate","title":"Estimating \\(\\pi\\) Using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-pi-using-monte-carlo-methods","text":"","title":"Estimating \\(\\pi\\) Using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1-circle-based-monte-carlo-simulation","text":"","title":"Part 1: Circle-Based Monte Carlo Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation","text":"The idea is based on comparing the area of a unit circle (radius = 1) with the area of a square that bounds it. Area of the unit circle: \\(A_{\\text{circle}} = \\pi r^2 = \\pi\\) Area of the square: \\(A_{\\text{square}} = (2r)^2 = 4\\) Random points are uniformly distributed in the square. The ratio of points that fall inside the circle to the total number of points approximates the ratio of the areas: \\[ \\frac{\\text{points inside circle}}{\\text{total points}} \\approx \\frac{\\pi}{4} \\] Thus, we can estimate \\(\\pi\\) using: \\[ \\pi \\approx 4 \\cdot \\frac{\\text{points inside circle}}{\\text{total points}} \\]","title":"1. Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-python-simulation-circle-method","text":"import numpy as np import matplotlib.pyplot as plt def estimate_pi_circle(n_points): x = np.random.uniform(-1, 1, n_points) y = np.random.uniform(-1, 1, n_points) inside_circle = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside_circle) / n_points # Visualization plt.figure(figsize=(6,6)) plt.scatter(x[inside_circle], y[inside_circle], s=1, color='blue', label='Inside Circle') plt.scatter(x[~inside_circle], y[~inside_circle], s=1, color='red', label='Outside Circle') circle = plt.Circle((0, 0), 1, fill=False, color='black', linestyle='--') plt.gca().add_artist(circle) plt.title(f\"Monte Carlo Pi Estimate: {pi_estimate:.5f}\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.axis('equal') plt.legend() plt.grid(True) plt.show() return pi_estimate # Example usage estimate_pi_circle(10000)","title":"2. Python Simulation (Circle Method)"},{"location":"1%20Physics/6%20Statistics/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2-buffons-needle-simulation","text":"","title":"Part 2: Buffon's Needle Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation_1","text":"Buffon's Needle problem involves dropping a needle of length \\(L\\) onto a floor with parallel lines spaced distance \\(D\\) apart. If \\(L \\leq D\\) , the probability \\(P\\) that the needle crosses a line is: \\[ P = \\frac{2L}{\\pi D} \\] Rearranging gives an estimate for \\(\\pi\\) : \\[ \\pi \\approx \\frac{2L \\cdot N}{D \\cdot C} \\] Where: - \\(N\\) = total needle drops - \\(C\\) = number of crossings","title":"1. Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-python-simulation-buffons-needle","text":"import numpy as np import matplotlib.pyplot as plt def estimate_pi_buffon(n_drops, needle_length=1.0, line_distance=2.0): assert needle_length <= line_distance, \"Needle length must be <= line spacing\" # Randomly generate needle centers and angles centers = np.random.uniform(0, line_distance / 2, n_drops) angles = np.random.uniform(0, np.pi / 2, n_drops) crosses = centers <= (needle_length / 2) * np.sin(angles) # Estimate pi n_crosses = np.sum(crosses) if n_crosses == 0: return None # Avoid division by zero pi_estimate = (2 * needle_length * n_drops) / (line_distance * n_crosses) # Visualization plt.figure(figsize=(6,6)) for i in range(100): x0 = np.random.uniform(0, 10) y0 = np.random.uniform(0, 10) theta = np.random.uniform(0, 2 * np.pi) x1 = x0 + (needle_length / 2) * np.cos(theta) x2 = x0 - (needle_length / 2) * np.cos(theta) y1 = y0 + (needle_length / 2) * np.sin(theta) y2 = y0 - (needle_length / 2) * np.sin(theta) plt.plot([x1, x2], [y1, y2], 'r-' if abs(y1 - y2) > line_distance else 'b-') for i in range(0, 11): plt.axhline(i, color='black', linestyle='--', linewidth=0.5) plt.title(f\"Buffon's Needle Pi Estimate: {pi_estimate:.5f}\") plt.xlim(0, 10) plt.ylim(0, 10) plt.gca().set_aspect('equal') plt.show() return pi_estimate # Example usage estimate_pi_buffon(10000)","title":"2. Python Simulation (Buffon's Needle)"},{"location":"1%20Physics/6%20Statistics/Problem_2/#_2","text":"","title":""},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-3-convergence-and-analysis","text":"As the number of iterations ( \\(N\\) ) increases, the estimates for \\(\\pi\\) from both methods converge toward the true value. Circle-based estimation usually converges faster and is simpler to implement.","title":"Part 3: Convergence and Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#summary-comparison-table","text":"Method Formula Used Convergence Rate Visualization Simplicity Accuracy (for large \\(N\\) ) Circle Method \\(\\pi \\approx 4 \\cdot \\frac{\\text{inside}}{\\text{total}}\\) Fast High High Buffon's Needle \\(\\pi \\approx \\frac{2L \\cdot N}{D \\cdot C}\\) Slow Moderate Moderate","title":"Summary Comparison Table"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"}]}