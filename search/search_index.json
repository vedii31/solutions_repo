{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Investigating the Range as a Function of the Angle of Projection 1. Introduction Projectile motion is a classical problem in physics, demonstrating fundamental principles of kinematics and dynamics. The study of projectile motion has extensive applications in fields like engineering, sports, ballistics, aerospace, and video game physics . This report explores how the range of a projectile depends on its angle of projection. By analyzing these dependencies, we uncover important insights into real-world problems, from optimizing a soccer kick to launching spacecrafts. Key Questions Explored: How does the range of a projectile change with launch angle? What is the optimal launch angle for maximum range? How do environmental factors (air resistance, wind, gravity variations) impact projectile motion? 2. Theoretical Foundations 2.1 Governing Equations of Motion Projectile motion follows Newton\u2019s Laws , particularly the equations of motion under uniform acceleration. Given an initial velocity \\(v_0\\) and launch angle \\(\\theta\\) , we break the motion into: Horizontal Motion \\[ x = v_0 \\cos(\\theta) t \\] \\[ v_x = v_0 \\cos(\\theta) \\quad (\\text{constant}) \\] Vertical Motion \\[ y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] \\[ v_y = v_0 \\sin(\\theta) - g t \\] where: - \\(g\\) is the acceleration due to gravity (9.81 m/s\u00b2 on Earth). 2.2 Time of Flight The projectile reaches the ground when \\(y = 0\\) : \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\] 2.3 Range Equation The horizontal distance (range) at landing is: \\[ R = v_0 \\cos(\\theta) t_f = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] From this equation, we note: Max range occurs at \\(\\theta = 45^\\circ\\) . Range is symmetric: \\(30^\\circ\\) and \\(60^\\circ\\) give the same range. 3. Advanced Theoretical Considerations 3.1 Finding the Maximum Range Taking the derivative of \\(R(\\theta)\\) and setting it to zero: \\[ \\frac{dR}{d\\theta} = \\frac{2 v_0^2 \\cos(2\\theta)}{g} = 0 \\] Solving for \\(\\theta\\) : \\[ 2\\theta = 90^\\circ \\Rightarrow \\theta = 45^\\circ \\] Thus, the maximum range is at \\(45^\\circ\\) . 3.2 Effect of Air Resistance With air resistance \\(F_d = \\frac{1}{2} C_d \\rho A v^2\\) , the equations become: \\[ m \\frac{dv_x}{dt} = -F_d \\cos(\\theta) \\] \\[ m \\frac{dv_y}{dt} = -mg - F_d \\sin(\\theta) \\] These equations require numerical methods for solutions. 4. Python Implementation 4.1 Range vs. Angle (Basic Model) import numpy as np import matplotlib.pyplot as plt def projectile_range(v0, theta, g=9.81): return (v0**2 * np.sin(2 * np.radians(theta))) / g angles = np.linspace(0, 90, 100) v0_values = [10, 20, 30] plt.figure(figsize=(8,5)) for v0 in v0_values: ranges = [projectile_range(v0, theta) for theta in angles] plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.axvline(45, linestyle='--', color='black', label='Max at 45\u00b0') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.title('Projectile Range vs. Launch Angle') plt.legend() plt.grid() plt.show() from mpl_toolkits.mplot3d import Axes3D fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') for theta in [30, 45, 60]: t = np.linspace(0, 2*v0*np.sin(np.radians(theta))/g, 100) x = v0 * np.cos(np.radians(theta)) * t y = v0 * np.sin(np.radians(theta)) * t - 0.5 * g * t**2 ax.plot(x, t, y, label=f'\u03b8 = {theta}\u00b0') ax.set_xlabel('Horizontal Distance') ax.set_ylabel('Time') ax.set_zlabel('Vertical Height') ax.legend() plt.show() def projectile_with_drag(v0, theta, g=9.81, Cd=0.47, rho=1.225, A=0.01, m=0.1, dt=0.01): vx = v0 * np.cos(np.radians(theta)) vy = v0 * np.sin(np.radians(theta)) x, y = 0, 0 positions = [] while y >= 0: v = np.sqrt(vx**2 + vy**2) Fd = 0.5 * Cd * rho * A * v**2 ax = -Fd * vx / m ay = -g - (Fd * vy / m) vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt positions.append((x, y)) return np.array(positions) pos = projectile_with_drag(20, 45) plt.plot(pos[:, 0], pos[:, 1], label='With Air Resistance') plt.xlabel('Horizontal Distance') plt.ylabel('Vertical Height') plt.title('Projectile Motion with Air Resistance') plt.legend() plt.grid() plt.show() 5. Real-World Applications Sports: Optimizing soccer free kicks, basketball shots, and javelin throws. Engineering: Calculating projectile paths in ballistics and aerospace. Space Science: Determining launch angles for interplanetary missions. Video Games: Simulating realistic projectile motion in physics engines. 6. Conclusion & Future Work Projectile motion is fundamental in physics, but real-world factors like air resistance, wind, and non-uniform gravity make it complex. Future studies can use: Machine Learning for predictive modeling of projectile behavior. CFD Simulations to analyze drag forces in different environments. Monte Carlo Methods for uncertainty analysis in real-world applications. This study provides a detailed framework for analyzing projectile motion and lays the foundation for more advanced research in physics, engineering, and beyond.","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-introduction","text":"Projectile motion is a classical problem in physics, demonstrating fundamental principles of kinematics and dynamics. The study of projectile motion has extensive applications in fields like engineering, sports, ballistics, aerospace, and video game physics . This report explores how the range of a projectile depends on its angle of projection. By analyzing these dependencies, we uncover important insights into real-world problems, from optimizing a soccer kick to launching spacecrafts.","title":"1. Introduction"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-questions-explored","text":"How does the range of a projectile change with launch angle? What is the optimal launch angle for maximum range? How do environmental factors (air resistance, wind, gravity variations) impact projectile motion?","title":"Key Questions Explored:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-theoretical-foundations","text":"","title":"2. Theoretical Foundations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#21-governing-equations-of-motion","text":"Projectile motion follows Newton\u2019s Laws , particularly the equations of motion under uniform acceleration. Given an initial velocity \\(v_0\\) and launch angle \\(\\theta\\) , we break the motion into:","title":"2.1 Governing Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion","text":"\\[ x = v_0 \\cos(\\theta) t \\] \\[ v_x = v_0 \\cos(\\theta) \\quad (\\text{constant}) \\]","title":"Horizontal Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion","text":"\\[ y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] \\[ v_y = v_0 \\sin(\\theta) - g t \\] where: - \\(g\\) is the acceleration due to gravity (9.81 m/s\u00b2 on Earth). 2.2 Time of Flight The projectile reaches the ground when \\(y = 0\\) : \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\] 2.3 Range Equation The horizontal distance (range) at landing is: \\[ R = v_0 \\cos(\\theta) t_f = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] From this equation, we note: Max range occurs at \\(\\theta = 45^\\circ\\) . Range is symmetric: \\(30^\\circ\\) and \\(60^\\circ\\) give the same range.","title":"Vertical Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-advanced-theoretical-considerations","text":"","title":"3. Advanced Theoretical Considerations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#31-finding-the-maximum-range","text":"Taking the derivative of \\(R(\\theta)\\) and setting it to zero: \\[ \\frac{dR}{d\\theta} = \\frac{2 v_0^2 \\cos(2\\theta)}{g} = 0 \\] Solving for \\(\\theta\\) : \\[ 2\\theta = 90^\\circ \\Rightarrow \\theta = 45^\\circ \\] Thus, the maximum range is at \\(45^\\circ\\) .","title":"3.1 Finding the Maximum Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#32-effect-of-air-resistance","text":"With air resistance \\(F_d = \\frac{1}{2} C_d \\rho A v^2\\) , the equations become: \\[ m \\frac{dv_x}{dt} = -F_d \\cos(\\theta) \\] \\[ m \\frac{dv_y}{dt} = -mg - F_d \\sin(\\theta) \\] These equations require numerical methods for solutions.","title":"3.2 Effect of Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-python-implementation","text":"","title":"4. Python Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#41-range-vs-angle-basic-model","text":"import numpy as np import matplotlib.pyplot as plt def projectile_range(v0, theta, g=9.81): return (v0**2 * np.sin(2 * np.radians(theta))) / g angles = np.linspace(0, 90, 100) v0_values = [10, 20, 30] plt.figure(figsize=(8,5)) for v0 in v0_values: ranges = [projectile_range(v0, theta) for theta in angles] plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.axvline(45, linestyle='--', color='black', label='Max at 45\u00b0') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.title('Projectile Range vs. Launch Angle') plt.legend() plt.grid() plt.show() from mpl_toolkits.mplot3d import Axes3D fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') for theta in [30, 45, 60]: t = np.linspace(0, 2*v0*np.sin(np.radians(theta))/g, 100) x = v0 * np.cos(np.radians(theta)) * t y = v0 * np.sin(np.radians(theta)) * t - 0.5 * g * t**2 ax.plot(x, t, y, label=f'\u03b8 = {theta}\u00b0') ax.set_xlabel('Horizontal Distance') ax.set_ylabel('Time') ax.set_zlabel('Vertical Height') ax.legend() plt.show() def projectile_with_drag(v0, theta, g=9.81, Cd=0.47, rho=1.225, A=0.01, m=0.1, dt=0.01): vx = v0 * np.cos(np.radians(theta)) vy = v0 * np.sin(np.radians(theta)) x, y = 0, 0 positions = [] while y >= 0: v = np.sqrt(vx**2 + vy**2) Fd = 0.5 * Cd * rho * A * v**2 ax = -Fd * vx / m ay = -g - (Fd * vy / m) vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt positions.append((x, y)) return np.array(positions) pos = projectile_with_drag(20, 45) plt.plot(pos[:, 0], pos[:, 1], label='With Air Resistance') plt.xlabel('Horizontal Distance') plt.ylabel('Vertical Height') plt.title('Projectile Motion with Air Resistance') plt.legend() plt.grid() plt.show()","title":"4.1 Range vs. Angle (Basic Model)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-real-world-applications","text":"","title":"5. Real-World Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#sports","text":"Optimizing soccer free kicks, basketball shots, and javelin throws.","title":"Sports:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#engineering","text":"Calculating projectile paths in ballistics and aerospace.","title":"Engineering:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#space-science","text":"Determining launch angles for interplanetary missions.","title":"Space Science:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#video-games","text":"Simulating realistic projectile motion in physics engines.","title":"Video Games:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#6-conclusion-future-work","text":"Projectile motion is fundamental in physics, but real-world factors like air resistance, wind, and non-uniform gravity make it complex. Future studies can use: Machine Learning for predictive modeling of projectile behavior. CFD Simulations to analyze drag forces in different environments. Monte Carlo Methods for uncertainty analysis in real-world applications. This study provides a detailed framework for analyzing projectile motion and lays the foundation for more advanced research in physics, engineering, and beyond.","title":"6. Conclusion &amp; Future Work"},{"location":"1%20Physics/1%20Mechanics/problemsecond/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum 1. Understanding the Physical System A pendulum is a fundamental mechanical system that exhibits a variety of motion types, including periodic, damped, and chaotic behaviors, depending on external influences. When damping (friction) and external periodic forcing are introduced, the motion becomes more complex and can exhibit chaotic behavior. The governing equation of motion for a forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement (radians). - \\(b\\) is the damping coefficient, accounting for resistive forces. - \\(g\\) is the acceleration due to gravity. - \\(L\\) is the length of the pendulum. - \\(A \\cos(\\omega t)\\) represents the external periodic driving force with amplitude \\(A\\) and frequency \\(\\omega\\) . Key Concepts Simple Harmonic Motion : If \\(b = 0\\) and \\(A = 0\\) , the motion is simple harmonic for small angles. Damped Motion : If \\(b > 0\\) and \\(A = 0\\) , oscillations decay over time due to resistive forces. Forced Motion : If \\(A > 0\\) , an external force drives the pendulum, leading to resonance and chaotic behavior. 2. Transforming the Equation for Numerical Methods The equation above is a second-order differential equation , which must be rewritten as a system of first-order equations for numerical solving. Defining State Variables We introduce: - \\(\\theta_1 = \\theta\\) (position) - \\(\\theta_2 = \\frac{d\\theta}{dt}\\) (velocity) Rewriting the system: \\[ \\frac{d\\theta_1}{dt} = \\theta_2 \\] \\[ \\frac{d\\theta_2}{dt} = -b\\theta_2 - \\frac{g}{L} \\sin\\theta_1 + A \\cos(\\omega t) \\] This form allows us to apply numerical integration techniques like Runge-Kutta (RK45) . 3. Choosing a Numerical Solver We employ the Runge-Kutta (RK45) method , which is well-suited for solving nonlinear differential equations. This method is preferred because: It handles nonlinearity effectively. It dynamically adjusts step size for accuracy. It is frequently used for chaotic systems like the forced damped pendulum. 4. Setting Up Initial Conditions The initial state of the pendulum significantly affects its behavior. We define: \\[ \\theta(0) = \\theta_0, \\quad \\frac{d\\theta}{dt}(0) = \\omega_0 \\] For example: - Small initial displacement : \\(\\theta_0 = 0.1\\) rad. - Initially at rest : \\(\\omega_0 = 0\\) rad/s. 5. Running the Simulation To numerically integrate the system: 1. Define the time span for simulation (e.g., \\(t \\in [0, 50]\\) ). 2. Solve the equations using the RK45 method . 3. Store and analyze the results over time. Implementation in Python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # Gravity (m/s^2) L = 1.0 # Length of the pendulum (m) b = 0.2 # Damping coefficient omega = 2.0 # Driving frequency # Define the system of ODEs def forced_damped_pendulum(t, y, A, omega): theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Initial conditions t0, t_end = 0, 50 initial_conditions = [0.1, 0] # Small initial angle and zero initial velocity # Solve the system time_eval = np.linspace(t0, t_end, 2000) A = 1.2 # Set A for initial run sol = solve_ivp(forced_damped_pendulum, [t0, t_end], initial_conditions, args=(A, omega), t_eval=time_eval, method='RK45') # Extract results theta = sol.y[0] omega_values = sol.y[1] time = sol.t # Time Series Plot plt.figure(figsize=(10, 5)) plt.plot(time, theta, label=r'$\\theta(t)$', color='b') plt.xlabel('Time (s)') plt.ylabel('Angular Position (rad)') plt.title('Forced Damped Pendulum Motion') plt.legend() plt.grid() plt.show() # Phase Portrait plt.figure(figsize=(6, 6)) plt.plot(theta, omega_values, lw=0.8, color='r') plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title('Phase Portrait') plt.grid() plt.show() # Poincar\u00e9 Section (Stroboscopic Map) omega_scalar = float(np.mean(omega_values)) if isinstance(omega_values, np.ndarray) else omega if omega_scalar != 0: poincare_times = np.arange(t0, t_end, 2 * np.pi / omega_scalar) else: poincare_times = np.linspace(t0, t_end, 50) # Fallback to evenly spaced points theta_poincare = np.interp(poincare_times, time, theta) omega_poincare = np.interp(poincare_times, time, omega_values) plt.figure(figsize=(6, 6)) plt.scatter(theta_poincare, omega_poincare, s=10, color='green') plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title('Poincar\u00e9 Section') plt.grid() plt.show() # Bifurcation Diagram - Sweeping Driving Force Amplitude A_values = np.linspace(0, 2, 50) final_theta = [] for A_val in A_values: sol = solve_ivp(forced_damped_pendulum, [t0, t_end], initial_conditions, args=(A_val, omega), t_eval=np.linspace(t_end-10, t_end, 500), method='RK45') final_theta.append(sol.y[0][-1]) plt.figure(figsize=(10, 6)) plt.scatter(A_values, final_theta, s=1, color='blue') plt.xlabel('Driving Force Amplitude (A)') plt.ylabel('Final Angular Position (rad)') plt.title('Bifurcation Diagram') plt.grid() plt.show() 6. Visualizing Results After solving for \\(\\theta(t)\\) , we analyze its behavior using different graphical representations: (a) Time Series Plot Shows how \\(\\theta(t)\\) evolves over time. Helps detect periodicity, resonance, or chaotic motion. (b) Phase Portrait Plots angular position ( \\(\\theta\\) ) vs. angular velocity ( \\(\\dot{\\theta}\\) ) . Closed loops indicate periodic motion, while scattered points suggest chaos. (c) Poincar\u00e9 Section Captures stroboscopic points sampled at regular intervals. Helps distinguish between regular and chaotic motion . (d) Bifurcation Diagram Varies the driving force amplitude (A) to observe transitions in motion. Reveals transitions from stability to chaos . 7. Analyzing the Behavior Different values of parameters lead to different types of motion: (a) Small Forcing and Weak Damping The pendulum exhibits simple periodic oscillations . The phase portrait shows smooth elliptical loops . (b) Resonance Condition When \\(\\omega\\) matches the natural frequency \\(\\omega_0 = \\sqrt{g/L}\\) , large oscillations occur. Energy accumulates over time, leading to strong oscillations. (c) Strong Damping Oscillations decay quickly, leading to overdamped motion . (d) Chaotic Motion For specific values of \\(A\\) and \\(\\omega\\) , the system exhibits sensitive dependence on initial conditions . Small changes in \\(\\theta_0\\) lead to divergent trajectories (butterfly effect). 8. Conclusion The forced damped pendulum is a rich nonlinear system that displays a variety of behaviors, from periodic to chaotic motion. Using numerical simulations , we can analyze its response to different parameters. Tools like Poincar\u00e9 sections and bifurcation diagrams help classify its dynamical regimes.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#1-understanding-the-physical-system","text":"A pendulum is a fundamental mechanical system that exhibits a variety of motion types, including periodic, damped, and chaotic behaviors, depending on external influences. When damping (friction) and external periodic forcing are introduced, the motion becomes more complex and can exhibit chaotic behavior. The governing equation of motion for a forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement (radians). - \\(b\\) is the damping coefficient, accounting for resistive forces. - \\(g\\) is the acceleration due to gravity. - \\(L\\) is the length of the pendulum. - \\(A \\cos(\\omega t)\\) represents the external periodic driving force with amplitude \\(A\\) and frequency \\(\\omega\\) .","title":"1. Understanding the Physical System"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#key-concepts","text":"Simple Harmonic Motion : If \\(b = 0\\) and \\(A = 0\\) , the motion is simple harmonic for small angles. Damped Motion : If \\(b > 0\\) and \\(A = 0\\) , oscillations decay over time due to resistive forces. Forced Motion : If \\(A > 0\\) , an external force drives the pendulum, leading to resonance and chaotic behavior.","title":"Key Concepts"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#2-transforming-the-equation-for-numerical-methods","text":"The equation above is a second-order differential equation , which must be rewritten as a system of first-order equations for numerical solving.","title":"2. Transforming the Equation for Numerical Methods"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#defining-state-variables","text":"We introduce: - \\(\\theta_1 = \\theta\\) (position) - \\(\\theta_2 = \\frac{d\\theta}{dt}\\) (velocity) Rewriting the system: \\[ \\frac{d\\theta_1}{dt} = \\theta_2 \\] \\[ \\frac{d\\theta_2}{dt} = -b\\theta_2 - \\frac{g}{L} \\sin\\theta_1 + A \\cos(\\omega t) \\] This form allows us to apply numerical integration techniques like Runge-Kutta (RK45) .","title":"Defining State Variables"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#3-choosing-a-numerical-solver","text":"We employ the Runge-Kutta (RK45) method , which is well-suited for solving nonlinear differential equations. This method is preferred because: It handles nonlinearity effectively. It dynamically adjusts step size for accuracy. It is frequently used for chaotic systems like the forced damped pendulum.","title":"3. Choosing a Numerical Solver"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#4-setting-up-initial-conditions","text":"The initial state of the pendulum significantly affects its behavior. We define: \\[ \\theta(0) = \\theta_0, \\quad \\frac{d\\theta}{dt}(0) = \\omega_0 \\] For example: - Small initial displacement : \\(\\theta_0 = 0.1\\) rad. - Initially at rest : \\(\\omega_0 = 0\\) rad/s.","title":"4. Setting Up Initial Conditions"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#5-running-the-simulation","text":"To numerically integrate the system: 1. Define the time span for simulation (e.g., \\(t \\in [0, 50]\\) ). 2. Solve the equations using the RK45 method . 3. Store and analyze the results over time.","title":"5. Running the Simulation"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#implementation-in-python","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # Gravity (m/s^2) L = 1.0 # Length of the pendulum (m) b = 0.2 # Damping coefficient omega = 2.0 # Driving frequency # Define the system of ODEs def forced_damped_pendulum(t, y, A, omega): theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Initial conditions t0, t_end = 0, 50 initial_conditions = [0.1, 0] # Small initial angle and zero initial velocity # Solve the system time_eval = np.linspace(t0, t_end, 2000) A = 1.2 # Set A for initial run sol = solve_ivp(forced_damped_pendulum, [t0, t_end], initial_conditions, args=(A, omega), t_eval=time_eval, method='RK45') # Extract results theta = sol.y[0] omega_values = sol.y[1] time = sol.t # Time Series Plot plt.figure(figsize=(10, 5)) plt.plot(time, theta, label=r'$\\theta(t)$', color='b') plt.xlabel('Time (s)') plt.ylabel('Angular Position (rad)') plt.title('Forced Damped Pendulum Motion') plt.legend() plt.grid() plt.show() # Phase Portrait plt.figure(figsize=(6, 6)) plt.plot(theta, omega_values, lw=0.8, color='r') plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title('Phase Portrait') plt.grid() plt.show() # Poincar\u00e9 Section (Stroboscopic Map) omega_scalar = float(np.mean(omega_values)) if isinstance(omega_values, np.ndarray) else omega if omega_scalar != 0: poincare_times = np.arange(t0, t_end, 2 * np.pi / omega_scalar) else: poincare_times = np.linspace(t0, t_end, 50) # Fallback to evenly spaced points theta_poincare = np.interp(poincare_times, time, theta) omega_poincare = np.interp(poincare_times, time, omega_values) plt.figure(figsize=(6, 6)) plt.scatter(theta_poincare, omega_poincare, s=10, color='green') plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title('Poincar\u00e9 Section') plt.grid() plt.show() # Bifurcation Diagram - Sweeping Driving Force Amplitude A_values = np.linspace(0, 2, 50) final_theta = [] for A_val in A_values: sol = solve_ivp(forced_damped_pendulum, [t0, t_end], initial_conditions, args=(A_val, omega), t_eval=np.linspace(t_end-10, t_end, 500), method='RK45') final_theta.append(sol.y[0][-1]) plt.figure(figsize=(10, 6)) plt.scatter(A_values, final_theta, s=1, color='blue') plt.xlabel('Driving Force Amplitude (A)') plt.ylabel('Final Angular Position (rad)') plt.title('Bifurcation Diagram') plt.grid() plt.show()","title":"Implementation in Python"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#6-visualizing-results","text":"After solving for \\(\\theta(t)\\) , we analyze its behavior using different graphical representations:","title":"6. Visualizing Results"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#a-time-series-plot","text":"Shows how \\(\\theta(t)\\) evolves over time. Helps detect periodicity, resonance, or chaotic motion.","title":"(a) Time Series Plot"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#b-phase-portrait","text":"Plots angular position ( \\(\\theta\\) ) vs. angular velocity ( \\(\\dot{\\theta}\\) ) . Closed loops indicate periodic motion, while scattered points suggest chaos.","title":"(b) Phase Portrait"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#c-poincare-section","text":"Captures stroboscopic points sampled at regular intervals. Helps distinguish between regular and chaotic motion .","title":"(c) Poincar\u00e9 Section"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#d-bifurcation-diagram","text":"Varies the driving force amplitude (A) to observe transitions in motion. Reveals transitions from stability to chaos .","title":"(d) Bifurcation Diagram"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#7-analyzing-the-behavior","text":"Different values of parameters lead to different types of motion:","title":"7. Analyzing the Behavior"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#a-small-forcing-and-weak-damping","text":"The pendulum exhibits simple periodic oscillations . The phase portrait shows smooth elliptical loops .","title":"(a) Small Forcing and Weak Damping"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#b-resonance-condition","text":"When \\(\\omega\\) matches the natural frequency \\(\\omega_0 = \\sqrt{g/L}\\) , large oscillations occur. Energy accumulates over time, leading to strong oscillations.","title":"(b) Resonance Condition"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#c-strong-damping","text":"Oscillations decay quickly, leading to overdamped motion .","title":"(c) Strong Damping"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#d-chaotic-motion","text":"For specific values of \\(A\\) and \\(\\omega\\) , the system exhibits sensitive dependence on initial conditions . Small changes in \\(\\theta_0\\) lead to divergent trajectories (butterfly effect).","title":"(d) Chaotic Motion"},{"location":"1%20Physics/1%20Mechanics/problemsecond/#8-conclusion","text":"The forced damped pendulum is a rich nonlinear system that displays a variety of behaviors, from periodic to chaotic motion. Using numerical simulations , we can analyze its response to different parameters. Tools like Poincar\u00e9 sections and bifurcation diagrams help classify its dynamical regimes.","title":"8. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 # Orbital Period and Orbital Radius Motivation Kepler's Third Law provides a fundamental insight into orbital mechanics: The square of the orbital period ( \\(T^2\\) ) of a planet is directly proportional to the cube of the semi-major axis ( \\(r^3\\) ) of its orbit: \\[ T^2 \\propto r^3 \\] This law is essential for understanding the motion of celestial bodies under the influence of gravity. Derivation for Circular Orbits Consider a body of mass \\(m\\) orbiting a larger mass \\(M\\) (e.g., a planet orbiting the Sun) in a circular orbit. Gravitational force provides the necessary centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Simplify and solve for velocity \\(v\\) : \\[ v^2 = \\frac{G M}{r} \\] Orbital period is: \\[ T = \\frac{2\\pi r}{v} \\] Substitute \\(v\\) : \\[ T = 2\\pi r \\sqrt{\\frac{r}{G M}} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] Therefore, \\[ T^2 = \\frac{4\\pi^2 r^3}{G M} \\] This confirms Kepler's Third Law: \\[ T^2 \\propto r^3 \\] Implications in Astronomy Allows determination of planetary masses. Enables calculation of distances in planetary systems. Satellite orbit planning relies heavily on this law. Used in exoplanet studies to estimate star and planet properties. Real-World Examples Example: Moon Around Earth Orbital radius \\(r \\approx 3.84 \\times 10^8\\) m Orbital period \\(T \\approx 27.3\\) days \\(= 2.36 \\times 10^6\\) s Compute \\(\\frac{T^2}{r^3}\\) : \\[ \\frac{(2.36 \\times 10^6)^2}{(3.84 \\times 10^8)^3} \\approx 2.95 \\times 10^{-14} \\] Example: Earth Around Sun \\(r \\approx 1.5 \\times 10^{11}\\) m \\(T = 1\\) year \\(= 3.15 \\times 10^7\\) s \\[ \\frac{T^2}{r^3} \\approx 2.96 \\times 10^{-19} \\] Python Simulation of Circular Orbits import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # mass of Earth (kg) radii = np.linspace(7e6, 4.2e7, 100) # from 7000 km to 42000 km # Calculate orbital period T for each radius T = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Plot T^2 vs r^3 plt.figure() plt.plot(radii**3, T**2, label=r'$T^2 \\propto r^3$') plt.xlabel(r'Orbital Radius Cubed $r^3$ (m$^3$)') plt.ylabel(r'Orbital Period Squared $T^2$ (s$^2$)') plt.title(\"Kepler's Third Law: $T^2$ vs $r^3$\") plt.grid(True) plt.legend() plt.show() Extension to Elliptical Orbits Kepler's Third Law also holds for elliptical orbits when \\(r\\) is replaced with the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4\\pi^2 a^3}{G M} \\] This general form explains motions of planets, comets, and exoplanets with non-circular orbits.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"# Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"Kepler's Third Law provides a fundamental insight into orbital mechanics: The square of the orbital period ( \\(T^2\\) ) of a planet is directly proportional to the cube of the semi-major axis ( \\(r^3\\) ) of its orbit: \\[ T^2 \\propto r^3 \\] This law is essential for understanding the motion of celestial bodies under the influence of gravity.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-for-circular-orbits","text":"Consider a body of mass \\(m\\) orbiting a larger mass \\(M\\) (e.g., a planet orbiting the Sun) in a circular orbit. Gravitational force provides the necessary centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Simplify and solve for velocity \\(v\\) : \\[ v^2 = \\frac{G M}{r} \\] Orbital period is: \\[ T = \\frac{2\\pi r}{v} \\] Substitute \\(v\\) : \\[ T = 2\\pi r \\sqrt{\\frac{r}{G M}} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] Therefore, \\[ T^2 = \\frac{4\\pi^2 r^3}{G M} \\] This confirms Kepler's Third Law: \\[ T^2 \\propto r^3 \\]","title":"Derivation for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications-in-astronomy","text":"Allows determination of planetary masses. Enables calculation of distances in planetary systems. Satellite orbit planning relies heavily on this law. Used in exoplanet studies to estimate star and planet properties.","title":"Implications in Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"","title":"Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-moon-around-earth","text":"Orbital radius \\(r \\approx 3.84 \\times 10^8\\) m Orbital period \\(T \\approx 27.3\\) days \\(= 2.36 \\times 10^6\\) s Compute \\(\\frac{T^2}{r^3}\\) : \\[ \\frac{(2.36 \\times 10^6)^2}{(3.84 \\times 10^8)^3} \\approx 2.95 \\times 10^{-14} \\]","title":"Example: Moon Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-earth-around-sun","text":"\\(r \\approx 1.5 \\times 10^{11}\\) m \\(T = 1\\) year \\(= 3.15 \\times 10^7\\) s \\[ \\frac{T^2}{r^3} \\approx 2.96 \\times 10^{-19} \\]","title":"Example: Earth Around Sun"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-simulation-of-circular-orbits","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # mass of Earth (kg) radii = np.linspace(7e6, 4.2e7, 100) # from 7000 km to 42000 km # Calculate orbital period T for each radius T = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Plot T^2 vs r^3 plt.figure() plt.plot(radii**3, T**2, label=r'$T^2 \\propto r^3$') plt.xlabel(r'Orbital Radius Cubed $r^3$ (m$^3$)') plt.ylabel(r'Orbital Period Squared $T^2$ (s$^2$)') plt.title(\"Kepler's Third Law: $T^2$ vs $r^3$\") plt.grid(True) plt.legend() plt.show()","title":"Python Simulation of Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extension-to-elliptical-orbits","text":"Kepler's Third Law also holds for elliptical orbits when \\(r\\) is replaced with the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4\\pi^2 a^3}{G M} \\] This general form explains motions of planets, comets, and exoplanets with non-circular orbits.","title":"Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 # Escape Velocities and Cosmic Velocities Motivation Escape velocity and the concept of cosmic velocities are essential to the understanding of gravitational dynamics in astrodynamics and interplanetary travel. They define the energy thresholds needed to transition between different gravitational regimes. This knowledge is crucial in designing space missions\u2014from launching satellites to exploring other planets and venturing beyond the solar system. Definitions First Cosmic Velocity ( \\(v_1\\) ) Also known as orbital velocity, this is the minimum velocity an object must maintain to stay in a stable circular orbit just above the surface of a celestial body: \\[ v_1 = \\sqrt{\\frac{G M}{R}} \\] Where: - \\(G\\) is the gravitational constant - \\(M\\) is the mass of the celestial body - \\(R\\) is the radius of the celestial body Second Cosmic Velocity ( \\(v_2\\) ) Escape velocity is the minimum speed needed to break free from a celestial body's gravitational pull without further propulsion: \\[ v_2 = \\sqrt{\\frac{2 G M}{R}} = \\sqrt{2} v_1 \\] This speed allows an object to move to infinity with zero residual velocity, assuming no resistance. Third Cosmic Velocity ( \\(v_3\\) ) This is the minimum velocity required for a spacecraft to escape not only Earth\u2019s gravity but also the Sun\u2019s, effectively allowing it to exit the solar system: \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{orbital}}^2} \\] Where \\(v_{\\text{orbital}}\\) is the orbital speed of the planet around the Sun. Factors Affecting Cosmic Velocities Mass ( \\(M\\) ) : Higher planetary mass increases the gravitational attraction, raising all three velocities. Radius ( \\(R\\) ) : Smaller radius increases surface gravity, raising the required velocities. Distance from other bodies : For \\(v_3\\) , the position in the solar system matters due to gravitational influence from the Sun and other planets. Python Code: Cosmic Velocities Simulation import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant in m^3/kg/s^2 # Planetary data: name, mass (kg), radius (m), orbital speed around Sun (m/s) bodies = { 'Earth': {'mass': 5.972e24, 'radius': 6.371e6, 'v_orbit': 29780}, 'Mars': {'mass': 6.417e23, 'radius': 3.390e6, 'v_orbit': 24070}, 'Jupiter': {'mass': 1.898e27, 'radius': 6.9911e7, 'v_orbit': 13070}, 'Moon': {'mass': 7.347e22, 'radius': 1.737e6, 'v_orbit': 1022}, 'Mercury': {'mass': 3.301e23, 'radius': 2.439e6, 'v_orbit': 47400}, 'Venus': {'mass': 4.867e24, 'radius': 6.052e6, 'v_orbit': 35000}, } # Calculate velocities results = {} for body, data in bodies.items(): M, R, v_orbit = data['mass'], data['radius'], data['v_orbit'] v1 = np.sqrt(G * M / R) v2 = np.sqrt(2 * G * M / R) v3 = np.sqrt(v2**2 + v_orbit**2) results[body] = {'v1': v1, 'v2': v2, 'v3': v3} # Print results print(\"Cosmic Velocities (in km/s):\\n\") for body, velocities in results.items(): print(f\"{body}:\") print(f\" First Cosmic Velocity (v1): {velocities['v1'] / 1000:.2f} km/s\") print(f\" Second Cosmic Velocity (v2): {velocities['v2'] / 1000:.2f} km/s\") print(f\" Third Cosmic Velocity (v3): {velocities['v3'] / 1000:.2f} km/s\\n\") # Visualization labels = list(bodies.keys()) v1_vals = [results[body]['v1'] / 1000 for body in labels] v2_vals = [results[body]['v2'] / 1000 for body in labels] v3_vals = [results[body]['v3'] / 1000 for body in labels] x = np.arange(len(labels)) width = 0.25 plt.figure(figsize=(12,7)) plt.bar(x - width, v1_vals, width, label='v1 - Orbital') plt.bar(x, v2_vals, width, label='v2 - Escape') plt.bar(x + width, v3_vals, width, label='v3 - Interstellar') plt.xticks(x, labels) plt.ylabel('Velocity (km/s)') plt.title('First, Second, and Third Cosmic Velocities') plt.legend() plt.grid(True) plt.tight_layout() plt.show() Analysis and Real-World Context Earth \\(v_1 \\approx 7.91\\) km/s: used for satellites in low Earth orbit. \\(v_2 \\approx 11.19\\) km/s: needed for lunar and interplanetary missions. \\(v_3 \\approx 42.1\\) km/s: required for spacecraft to leave the Solar System. Mars Lower gravity results in lower escape and orbital velocities. Useful for future Mars colonization and exploration missions. Jupiter Enormous gravity increases required velocities significantly. Missions to Jupiter require major energy inputs or gravity assists. Other Bodies The Moon's low gravity makes it an ideal candidate for a space station. Venus and Mercury, while closer to the Sun, still require precision due to solar gravity. Importance in Space Exploration First Cosmic Velocity : Key for satellite deployment and orbital stations. Second Cosmic Velocity : Used in deep-space missions (e.g., Mars, asteroids). Third Cosmic Velocity : Enables interstellar exploration (e.g., Voyager 1 & 2). Understanding and optimizing for these velocities ensures cost-effective and technically feasible space missions. Every planetary mission, satellite launch, or interstellar probe relies on these fundamental velocity thresholds.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"# Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"Escape velocity and the concept of cosmic velocities are essential to the understanding of gravitational dynamics in astrodynamics and interplanetary travel. They define the energy thresholds needed to transition between different gravitational regimes. This knowledge is crucial in designing space missions\u2014from launching satellites to exploring other planets and venturing beyond the solar system.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions","text":"","title":"Definitions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-v_1","text":"Also known as orbital velocity, this is the minimum velocity an object must maintain to stay in a stable circular orbit just above the surface of a celestial body: \\[ v_1 = \\sqrt{\\frac{G M}{R}} \\] Where: - \\(G\\) is the gravitational constant - \\(M\\) is the mass of the celestial body - \\(R\\) is the radius of the celestial body","title":"First Cosmic Velocity (\\(v_1\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-v_2","text":"Escape velocity is the minimum speed needed to break free from a celestial body's gravitational pull without further propulsion: \\[ v_2 = \\sqrt{\\frac{2 G M}{R}} = \\sqrt{2} v_1 \\] This speed allows an object to move to infinity with zero residual velocity, assuming no resistance.","title":"Second Cosmic Velocity (\\(v_2\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-v_3","text":"This is the minimum velocity required for a spacecraft to escape not only Earth\u2019s gravity but also the Sun\u2019s, effectively allowing it to exit the solar system: \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{orbital}}^2} \\] Where \\(v_{\\text{orbital}}\\) is the orbital speed of the planet around the Sun.","title":"Third Cosmic Velocity (\\(v_3\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#factors-affecting-cosmic-velocities","text":"Mass ( \\(M\\) ) : Higher planetary mass increases the gravitational attraction, raising all three velocities. Radius ( \\(R\\) ) : Smaller radius increases surface gravity, raising the required velocities. Distance from other bodies : For \\(v_3\\) , the position in the solar system matters due to gravitational influence from the Sun and other planets.","title":"Factors Affecting Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-code-cosmic-velocities-simulation","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant in m^3/kg/s^2 # Planetary data: name, mass (kg), radius (m), orbital speed around Sun (m/s) bodies = { 'Earth': {'mass': 5.972e24, 'radius': 6.371e6, 'v_orbit': 29780}, 'Mars': {'mass': 6.417e23, 'radius': 3.390e6, 'v_orbit': 24070}, 'Jupiter': {'mass': 1.898e27, 'radius': 6.9911e7, 'v_orbit': 13070}, 'Moon': {'mass': 7.347e22, 'radius': 1.737e6, 'v_orbit': 1022}, 'Mercury': {'mass': 3.301e23, 'radius': 2.439e6, 'v_orbit': 47400}, 'Venus': {'mass': 4.867e24, 'radius': 6.052e6, 'v_orbit': 35000}, } # Calculate velocities results = {} for body, data in bodies.items(): M, R, v_orbit = data['mass'], data['radius'], data['v_orbit'] v1 = np.sqrt(G * M / R) v2 = np.sqrt(2 * G * M / R) v3 = np.sqrt(v2**2 + v_orbit**2) results[body] = {'v1': v1, 'v2': v2, 'v3': v3} # Print results print(\"Cosmic Velocities (in km/s):\\n\") for body, velocities in results.items(): print(f\"{body}:\") print(f\" First Cosmic Velocity (v1): {velocities['v1'] / 1000:.2f} km/s\") print(f\" Second Cosmic Velocity (v2): {velocities['v2'] / 1000:.2f} km/s\") print(f\" Third Cosmic Velocity (v3): {velocities['v3'] / 1000:.2f} km/s\\n\") # Visualization labels = list(bodies.keys()) v1_vals = [results[body]['v1'] / 1000 for body in labels] v2_vals = [results[body]['v2'] / 1000 for body in labels] v3_vals = [results[body]['v3'] / 1000 for body in labels] x = np.arange(len(labels)) width = 0.25 plt.figure(figsize=(12,7)) plt.bar(x - width, v1_vals, width, label='v1 - Orbital') plt.bar(x, v2_vals, width, label='v2 - Escape') plt.bar(x + width, v3_vals, width, label='v3 - Interstellar') plt.xticks(x, labels) plt.ylabel('Velocity (km/s)') plt.title('First, Second, and Third Cosmic Velocities') plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"Python Code: Cosmic Velocities Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#analysis-and-real-world-context","text":"","title":"Analysis and Real-World Context"},{"location":"1%20Physics/2%20Gravity/Problem_2/#earth","text":"\\(v_1 \\approx 7.91\\) km/s: used for satellites in low Earth orbit. \\(v_2 \\approx 11.19\\) km/s: needed for lunar and interplanetary missions. \\(v_3 \\approx 42.1\\) km/s: required for spacecraft to leave the Solar System.","title":"Earth"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mars","text":"Lower gravity results in lower escape and orbital velocities. Useful for future Mars colonization and exploration missions.","title":"Mars"},{"location":"1%20Physics/2%20Gravity/Problem_2/#jupiter","text":"Enormous gravity increases required velocities significantly. Missions to Jupiter require major energy inputs or gravity assists.","title":"Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#other-bodies","text":"The Moon's low gravity makes it an ideal candidate for a space station. Venus and Mercury, while closer to the Sun, still require precision due to solar gravity.","title":"Other Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_2/#importance-in-space-exploration","text":"First Cosmic Velocity : Key for satellite deployment and orbital stations. Second Cosmic Velocity : Used in deep-space missions (e.g., Mars, asteroids). Third Cosmic Velocity : Enables interstellar exploration (e.g., Voyager 1 & 2). Understanding and optimizing for these velocities ensures cost-effective and technically feasible space missions. Every planetary mission, satellite launch, or interstellar probe relies on these fundamental velocity thresholds.","title":"Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 # Trajectories of a Freely Released Payload Near Earth Motivation When a payload is released from a spacecraft in orbit around Earth, its subsequent trajectory is governed by gravitational forces and its initial velocity and position. The object may re-enter Earth, remain in orbit, or escape into interplanetary space depending on its energy and direction. Analyzing these scenarios provides insights into orbital dynamics and mission planning. Fundamental Concepts Newton\u2019s Law of Universal Gravitation The force of gravity between Earth and the payload is: \\[ F = \\frac{G M m}{r^2} \\] Where: - \\(G = 6.67430 \\times 10^{-11}\\) m\u00b3/kg/s\u00b2 (gravitational constant) - \\(M\\) is the mass of Earth ( \\(5.972 \\times 10^{24}\\) kg) - \\(m\\) is the mass of the payload - \\(r\\) is the distance from Earth's center to the payload Gravitational Acceleration Acceleration due to gravity experienced by the payload is: \\[ \\vec{a} = -\\frac{G M}{r^3} \\vec{r} \\] This is a central force that always points toward the center of Earth. Energy-Based Classification of Trajectories The total mechanical energy \\(E\\) of the payload is the sum of kinetic and potential energy: \\[ E = \\frac{1}{2}mv^2 - \\frac{G M m}{r} \\] Depending on \\(E\\) , we classify the trajectory as: - Elliptical Orbit ( \\(E < 0\\) ): Bound orbit - Parabolic Trajectory ( \\(E = 0\\) ): Escape trajectory with minimum speed - Hyperbolic Trajectory ( \\(E > 0\\) ): Unbound escape trajectory The escape velocity at a distance \\(r\\) is: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2 G M}{r}} \\] Python Simulation: Numerical Integration of Trajectories import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 5.972e24 # kg (Earth) R = 6.371e6 # m (Earth radius) # Simulation parameters dt = 1.0 # seconds t_max = 20000 # total time steps = int(t_max / dt) # Initial position and velocity altitude = 300e3 # 300 km altitude r0 = np.array([R + altitude, 0]) v0 = np.array([0, 7800]) # m/s tangential velocity # Initialize arrays pos = np.zeros((steps, 2)) vel = np.zeros((steps, 2)) pos[0] = r0 vel[0] = v0 # Gravitational acceleration def acceleration(r): norm_r = np.linalg.norm(r) return -G * M * r / norm_r**3 # Euler integration for i in range(steps - 1): acc = acceleration(pos[i]) vel[i + 1] = vel[i] + acc * dt pos[i + 1] = pos[i] + vel[i + 1] * dt # Terminate if impact occurs if np.linalg.norm(pos[i + 1]) <= R: pos = pos[:i + 2] break # Plotting plt.figure(figsize=(8,8)) plt.plot(pos[:,0] / 1e3, pos[:,1] / 1e3, label='Payload Trajectory') # Draw Earth theta = np.linspace(0, 2*np.pi, 300) earth_x = R * np.cos(theta) / 1e3 earth_y = R * np.sin(theta) / 1e3 plt.plot(earth_x, earth_y, 'b', label='Earth') plt.xlabel('x (km)') plt.ylabel('y (km)') plt.title('Simulated Payload Trajectory Near Earth') plt.axis('equal') plt.grid(True) plt.legend() plt.show() Case Studies 1. Suborbital Re-entry If the payload velocity is too low, it follows a curved trajectory and returns to Earth. This is common in early ballistic missile flights and re-entry capsules. 2. Circular Orbit If velocity equals: \\[ v = \\sqrt{\\frac{G M}{r}} \\] The payload enters a circular orbit. This is how most satellites are initially inserted into low Earth orbit. 3. Elliptical Orbit A slightly higher or lower speed than the circular orbit velocity creates an elliptical orbit, with apogee and perigee. 4. Escape Trajectory If the payload exceeds escape velocity, it follows a parabolic or hyperbolic path, depending on the excess energy. Applications in Space Missions Satellite Deployment : Calculating correct release velocity ensures successful orbit. Re-entry Modules : Predicting descent paths improves safety and precision. Space Probes : Must achieve escape velocity for interplanetary missions. Orbital Maneuvers : Understanding how changes in velocity affect trajectory enables transfers (e.g., Hohmann transfer). Summary This detailed analysis and simulation illustrate how initial velocity and position determine a payload\u2019s trajectory. From orbital insertion to planetary escape, understanding the physics of motion near Earth is essential in aerospace design and mission execution. By adjusting these variables, we can achieve specific orbital goals or safely return payloads to Earth. Numerical simulation using Python allows us to model these scenarios precisely, opening pathways for deeper exploration of spaceflight dynamics.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"# Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When a payload is released from a spacecraft in orbit around Earth, its subsequent trajectory is governed by gravitational forces and its initial velocity and position. The object may re-enter Earth, remain in orbit, or escape into interplanetary space depending on its energy and direction. Analyzing these scenarios provides insights into orbital dynamics and mission planning.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#fundamental-concepts","text":"","title":"Fundamental Concepts"},{"location":"1%20Physics/2%20Gravity/Problem_3/#newtons-law-of-universal-gravitation","text":"The force of gravity between Earth and the payload is: \\[ F = \\frac{G M m}{r^2} \\] Where: - \\(G = 6.67430 \\times 10^{-11}\\) m\u00b3/kg/s\u00b2 (gravitational constant) - \\(M\\) is the mass of Earth ( \\(5.972 \\times 10^{24}\\) kg) - \\(m\\) is the mass of the payload - \\(r\\) is the distance from Earth's center to the payload","title":"Newton\u2019s Law of Universal Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#gravitational-acceleration","text":"Acceleration due to gravity experienced by the payload is: \\[ \\vec{a} = -\\frac{G M}{r^3} \\vec{r} \\] This is a central force that always points toward the center of Earth.","title":"Gravitational Acceleration"},{"location":"1%20Physics/2%20Gravity/Problem_3/#energy-based-classification-of-trajectories","text":"The total mechanical energy \\(E\\) of the payload is the sum of kinetic and potential energy: \\[ E = \\frac{1}{2}mv^2 - \\frac{G M m}{r} \\] Depending on \\(E\\) , we classify the trajectory as: - Elliptical Orbit ( \\(E < 0\\) ): Bound orbit - Parabolic Trajectory ( \\(E = 0\\) ): Escape trajectory with minimum speed - Hyperbolic Trajectory ( \\(E > 0\\) ): Unbound escape trajectory The escape velocity at a distance \\(r\\) is: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2 G M}{r}} \\]","title":"Energy-Based Classification of Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-simulation-numerical-integration-of-trajectories","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 5.972e24 # kg (Earth) R = 6.371e6 # m (Earth radius) # Simulation parameters dt = 1.0 # seconds t_max = 20000 # total time steps = int(t_max / dt) # Initial position and velocity altitude = 300e3 # 300 km altitude r0 = np.array([R + altitude, 0]) v0 = np.array([0, 7800]) # m/s tangential velocity # Initialize arrays pos = np.zeros((steps, 2)) vel = np.zeros((steps, 2)) pos[0] = r0 vel[0] = v0 # Gravitational acceleration def acceleration(r): norm_r = np.linalg.norm(r) return -G * M * r / norm_r**3 # Euler integration for i in range(steps - 1): acc = acceleration(pos[i]) vel[i + 1] = vel[i] + acc * dt pos[i + 1] = pos[i] + vel[i + 1] * dt # Terminate if impact occurs if np.linalg.norm(pos[i + 1]) <= R: pos = pos[:i + 2] break # Plotting plt.figure(figsize=(8,8)) plt.plot(pos[:,0] / 1e3, pos[:,1] / 1e3, label='Payload Trajectory') # Draw Earth theta = np.linspace(0, 2*np.pi, 300) earth_x = R * np.cos(theta) / 1e3 earth_y = R * np.sin(theta) / 1e3 plt.plot(earth_x, earth_y, 'b', label='Earth') plt.xlabel('x (km)') plt.ylabel('y (km)') plt.title('Simulated Payload Trajectory Near Earth') plt.axis('equal') plt.grid(True) plt.legend() plt.show()","title":"Python Simulation: Numerical Integration of Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_3/#case-studies","text":"","title":"Case Studies"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-suborbital-re-entry","text":"If the payload velocity is too low, it follows a curved trajectory and returns to Earth. This is common in early ballistic missile flights and re-entry capsules.","title":"1. Suborbital Re-entry"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-circular-orbit","text":"If velocity equals: \\[ v = \\sqrt{\\frac{G M}{r}} \\] The payload enters a circular orbit. This is how most satellites are initially inserted into low Earth orbit.","title":"2. Circular Orbit"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-elliptical-orbit","text":"A slightly higher or lower speed than the circular orbit velocity creates an elliptical orbit, with apogee and perigee.","title":"3. Elliptical Orbit"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-escape-trajectory","text":"If the payload exceeds escape velocity, it follows a parabolic or hyperbolic path, depending on the excess energy.","title":"4. Escape Trajectory"},{"location":"1%20Physics/2%20Gravity/Problem_3/#applications-in-space-missions","text":"Satellite Deployment : Calculating correct release velocity ensures successful orbit. Re-entry Modules : Predicting descent paths improves safety and precision. Space Probes : Must achieve escape velocity for interplanetary missions. Orbital Maneuvers : Understanding how changes in velocity affect trajectory enables transfers (e.g., Hohmann transfer).","title":"Applications in Space Missions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#summary","text":"This detailed analysis and simulation illustrate how initial velocity and position determine a payload\u2019s trajectory. From orbital insertion to planetary escape, understanding the physics of motion near Earth is essential in aerospace design and mission execution. By adjusting these variables, we can achieve specific orbital goals or safely return payloads to Earth. Numerical simulation using Python allows us to model these scenarios precisely, opening pathways for deeper exploration of spaceflight dynamics.","title":"Summary"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"\ud83c\udf0a Interference Patterns on a Water Surface \ud83c\udfaf Motivation Wave interference is a fundamental phenomenon where two or more waves overlap in space, leading to a new wave pattern. On a water surface, this is elegantly demonstrated when ripples from different points meet. Their superposition produces a pattern of reinforcement (constructive interference) and cancellation (destructive interference). These patterns not only provide visual insight into the physics of waves but also model various real-world phenomena including sound, light, and radio wave interactions. This project aims to visualize interference using wave sources placed at the vertices of a regular polygon. The symmetry and spacing of these sources produce rich interference patterns. \ud83e\uddee Theoretical Background Single Point Source Wave The displacement $( \\eta(x, y, t) $) on the surface of the water from a point source at position \\(((x_0, y_0)\\) ) is modeled by: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cos(kr - \\omega t + \\phi) \\] Where: - $( A $): Amplitude of the wave - $( r = \\sqrt{(x - x_0)^2 + (y - y_0)^2} $): Distance from source to point \\(((x, y)\\) ) - $( k = \\frac{2\\pi}{\\lambda} $): Wave number - $( \\lambda $): Wavelength - $( \\omega = 2\\pi f $): Angular frequency - $( f $): Frequency - $( \\phi $): Initial phase - $( t $): Time Superposition Principle With multiple coherent sources emitting waves of equal frequency and amplitude, the net displacement is the sum of all individual displacements: \\[ \\eta_{sum}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] Where $( N $) is the number of wave sources. \ud83d\udd27 Simulation Setup 1. Define Parameters Number of sources $( N $): Vertices of the polygon Radius $( R $): Distance from polygon center to each source Grid size: Area of simulation in the $( xy $)-plane 2. Create Wave Sources Sources are placed symmetrically around the origin using trigonometric functions. 3. Calculate Wave Contributions Use the distance formula for $( r $) Sum all contributions to get $( \\eta_{sum} $) 4. Visualization Use contour plots to show high and low displacement regions \ud83e\uddea Python Code import numpy as np import matplotlib.pyplot as plt # === Wave Parameters === A = 1.0 # Amplitude wavelength = 2.0 # Wavelength (lambda) f = 1.0 # Frequency (Hz) omega = 2 * np.pi * f k = 2 * np.pi / wavelength phi = 0 # Initial phase t = 0.0 # Snapshot at t seconds # === Polygon Configuration === N = 4 # Number of sources (3=triangle, 4=square, etc.) R = 5.0 # Radius from center to vertex # === Grid Setup === x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) # === Source Coordinates === sources = [] for i in range(N): angle = 2 * np.pi * i / N x0 = R * np.cos(angle) y0 = R * np.sin(angle) sources.append((x0, y0)) # === Wave Superposition === eta_sum = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) eta = A / np.sqrt(r + 1e-6) * np.cos(k * r - omega * t + phi) eta_sum += eta # === Plotting === plt.figure(figsize=(10, 8)) contour = plt.contourf(X, Y, eta_sum, levels=150, cmap='RdBu') plt.colorbar(contour, label='Wave Displacement') plt.title(f\"Interference Pattern: {N}-Vertex Regular Polygon\") plt.xlabel('x (units)') plt.ylabel('y (units)') plt.axis('equal') plt.grid(False) plt.show() \ud83d\udcca Observations and Analysis \ud83d\udd39 Constructive Interference Occurs at points where waves from all sources arrive in phase . Results in amplified displacement . \ud83d\udd38 Destructive Interference Occurs at points where waves arrive out of phase . Results in cancellation or reduced displacement. \ud83c\udf00 Symmetry and Patterns The rotational symmetry of the polygon is reflected in the interference pattern. As $( N $) increases, the pattern becomes more circular and complex. \ud83d\udd01 Possible Extensions Animation over time to show wave propagation Different phase shifts between sources Changing polygon types : triangle (N=3), pentagon (N=5), hexagon (N=6) Interactive UI using sliders for real-time parameter adjustment (with Jupyter widgets or Streamlit) \u2705 Conclusion This simulation visually demonstrates how regular spatial arrangements of coherent wave sources lead to predictable and beautiful interference patterns. The combination of theory and Python simulation provides a hands-on approach to mastering wave behavior and superposition.","title":"\ud83c\udf0a Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"\ud83c\udf0a Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Wave interference is a fundamental phenomenon where two or more waves overlap in space, leading to a new wave pattern. On a water surface, this is elegantly demonstrated when ripples from different points meet. Their superposition produces a pattern of reinforcement (constructive interference) and cancellation (destructive interference). These patterns not only provide visual insight into the physics of waves but also model various real-world phenomena including sound, light, and radio wave interactions. This project aims to visualize interference using wave sources placed at the vertices of a regular polygon. The symmetry and spacing of these sources produce rich interference patterns.","title":"\ud83c\udfaf Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#theoretical-background","text":"","title":"\ud83e\uddee Theoretical Background"},{"location":"1%20Physics/3%20Waves/Problem_1/#single-point-source-wave","text":"The displacement $( \\eta(x, y, t) $) on the surface of the water from a point source at position \\(((x_0, y_0)\\) ) is modeled by: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cos(kr - \\omega t + \\phi) \\] Where: - $( A $): Amplitude of the wave - $( r = \\sqrt{(x - x_0)^2 + (y - y_0)^2} $): Distance from source to point \\(((x, y)\\) ) - $( k = \\frac{2\\pi}{\\lambda} $): Wave number - $( \\lambda $): Wavelength - $( \\omega = 2\\pi f $): Angular frequency - $( f $): Frequency - $( \\phi $): Initial phase - $( t $): Time","title":"Single Point Source Wave"},{"location":"1%20Physics/3%20Waves/Problem_1/#superposition-principle","text":"With multiple coherent sources emitting waves of equal frequency and amplitude, the net displacement is the sum of all individual displacements: \\[ \\eta_{sum}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] Where $( N $) is the number of wave sources.","title":"Superposition Principle"},{"location":"1%20Physics/3%20Waves/Problem_1/#simulation-setup","text":"","title":"\ud83d\udd27 Simulation Setup"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-define-parameters","text":"Number of sources $( N $): Vertices of the polygon Radius $( R $): Distance from polygon center to each source Grid size: Area of simulation in the $( xy $)-plane","title":"1. Define Parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-create-wave-sources","text":"Sources are placed symmetrically around the origin using trigonometric functions.","title":"2. Create Wave Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-calculate-wave-contributions","text":"Use the distance formula for $( r $) Sum all contributions to get $( \\eta_{sum} $)","title":"3. Calculate Wave Contributions"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-visualization","text":"Use contour plots to show high and low displacement regions","title":"4. Visualization"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-code","text":"import numpy as np import matplotlib.pyplot as plt # === Wave Parameters === A = 1.0 # Amplitude wavelength = 2.0 # Wavelength (lambda) f = 1.0 # Frequency (Hz) omega = 2 * np.pi * f k = 2 * np.pi / wavelength phi = 0 # Initial phase t = 0.0 # Snapshot at t seconds # === Polygon Configuration === N = 4 # Number of sources (3=triangle, 4=square, etc.) R = 5.0 # Radius from center to vertex # === Grid Setup === x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) # === Source Coordinates === sources = [] for i in range(N): angle = 2 * np.pi * i / N x0 = R * np.cos(angle) y0 = R * np.sin(angle) sources.append((x0, y0)) # === Wave Superposition === eta_sum = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) eta = A / np.sqrt(r + 1e-6) * np.cos(k * r - omega * t + phi) eta_sum += eta # === Plotting === plt.figure(figsize=(10, 8)) contour = plt.contourf(X, Y, eta_sum, levels=150, cmap='RdBu') plt.colorbar(contour, label='Wave Displacement') plt.title(f\"Interference Pattern: {N}-Vertex Regular Polygon\") plt.xlabel('x (units)') plt.ylabel('y (units)') plt.axis('equal') plt.grid(False) plt.show()","title":"\ud83e\uddea Python Code"},{"location":"1%20Physics/3%20Waves/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/3%20Waves/Problem_1/#observations-and-analysis","text":"","title":"\ud83d\udcca Observations and Analysis"},{"location":"1%20Physics/3%20Waves/Problem_1/#constructive-interference","text":"Occurs at points where waves from all sources arrive in phase . Results in amplified displacement .","title":"\ud83d\udd39 Constructive Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#destructive-interference","text":"Occurs at points where waves arrive out of phase . Results in cancellation or reduced displacement.","title":"\ud83d\udd38 Destructive Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#symmetry-and-patterns","text":"The rotational symmetry of the polygon is reflected in the interference pattern. As $( N $) increases, the pattern becomes more circular and complex.","title":"\ud83c\udf00 Symmetry and Patterns"},{"location":"1%20Physics/3%20Waves/Problem_1/#possible-extensions","text":"Animation over time to show wave propagation Different phase shifts between sources Changing polygon types : triangle (N=3), pentagon (N=5), hexagon (N=6) Interactive UI using sliders for real-time parameter adjustment (with Jupyter widgets or Streamlit)","title":"\ud83d\udd01 Possible Extensions"},{"location":"1%20Physics/3%20Waves/Problem_1/#conclusion","text":"This simulation visually demonstrates how regular spatial arrangements of coherent wave sources lead to predictable and beautiful interference patterns. The combination of theory and Python simulation provides a hands-on approach to mastering wave behavior and superposition.","title":"\u2705 Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"}]}